<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê¸°ì–µë ¥ ì‘¥ì‘¥ & ìˆœë°œë ¥ ë²ˆì© ê²Œì„</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* CSS ì‹œì‘ */
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            /* íŒŒìŠ¤í…”í†¤ ê·¸ë¼ë°ì´ì…˜ ë°°ê²½ */
            background: linear-gradient(135deg, #e0f7fa, #c8e6c9); /* í•˜ëŠ˜ìƒ‰ì—ì„œ ì—°ë‘ìƒ‰ìœ¼ë¡œ */
            color: #333;
            overflow: hidden;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }

        #app {
            width: 100%;
            /* ìº”ë²„ìŠ¤ ì˜ì—­ì„ ë„“ê²Œ ëŠ˜ë¦¬ê¸° ìœ„í•´ max-widthë¥¼ 420pxì—ì„œ 600pxë¡œ ì¦ê°€ */
            max-width: 600px; 
            /* ì•± ë°°ê²½ë„ ë¶€ë“œëŸ¬ìš´ íŒŒìŠ¤í…”í†¤ìœ¼ë¡œ */
            background-color: #fcfcfc; 
            border-radius: 20px; /* ëª¨ì„œë¦¬ ë” ë‘¥ê¸€ê²Œ */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15); /* ê·¸ë¦¼ì ê°•í™” */
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            position: relative; /* ìì‹ ìš”ì†Œì˜ absolute ìœ„ì¹˜ ì§€ì •ì„ ìœ„í•´ ì¶”ê°€ */
        }

        /* í™”ë©´ ì „í™˜ */
        .screen {
            display: none;
            padding: 25px; /* íŒ¨ë”© ì¦ê°€ */
            text-align: center;
            flex-grow: 1;
        }

        .screen.active {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        /* í™ˆ í™”ë©´ ìŠ¤íƒ€ì¼ */
        #home-screen h1 {
            color: #6a0dad; /* ë³´ë¼ìƒ‰ ê³„ì—´ë¡œ ë³€ê²½ */
            margin-bottom: 30px;
            font-size: 2.2em; /* í°íŠ¸ í¬ê¸° ì¦ê°€ */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.05); /* í…ìŠ¤íŠ¸ ê·¸ë¦¼ì ì¶”ê°€ */
        }

        .game-selection-buttons { 
            display: flex;
            flex-direction: column;
            gap: 20px; /* ê°„ê²© ì¦ê°€ */
            width: 85%; /* ë„ˆë¹„ ì¦ê°€ */
            max-width: 350px; /* ìµœëŒ€ ë„ˆë¹„ ì¦ê°€ */
        }

        .difficulty-buttons, .game-buttons {
            display: flex;
            flex-direction: column;
            gap: 18px; /* ê°„ê²© ì¦ê°€ */
            width: 85%; 
            max-width: 350px;
        }
        
        .difficulty-buttons button, 
        .game-selection-buttons button,
        #memory-restart-button, #memory-home-button,
        #reaction-restart-button, #reaction-home-button,
        .gugudan-option-button, /* êµ¬êµ¬ë‹¨ ë²„íŠ¼ ì¶”ê°€ */
        #gugudan-restart-button, #gugudan-home-button /* êµ¬êµ¬ë‹¨ ë‹¤ì‹œ ì‹œì‘, í™ˆ ë²„íŠ¼ ì¶”ê°€ */
        {
            padding: 20px 28px; /* íŒ¨ë”© ì¦ê°€ */
            font-size: 1.4em; /* í°íŠ¸ í¬ê¸° ì¦ê°€ */
            font-weight: bold;
            color: #fff;
            /* íŒŒìŠ¤í…” ê·¸ë¼ë°ì´ì…˜ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
            background-image: linear-gradient(45deg, #a7e9af, #88d4ab); /* ì—°ë‘ìƒ‰ ê·¸ë¼ë°ì´ì…˜ */
            border: none;
            border-radius: 12px; /* ëª¨ì„œë¦¬ ë” ë‘¥ê¸€ê²Œ */
            cursor: pointer;
            transition: all 0.3s ease; /* ì „í™˜ íš¨ê³¼ ê°•í™” */
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2); /* ê·¸ë¦¼ì ê°•í™” */
            text-shadow: 1px 1px 3px rgba(0,0,0,0.1);
        }

        .difficulty-buttons button:hover, 
        .game-selection-buttons button:hover,
        #memory-restart-button:hover, #memory-home-button:hover,
        #reaction-restart-button:hover, #reaction-home-button:hover,
        .gugudan-option-button:hover,
        #gugudan-restart-button:hover, #gugudan-home-button:hover
        {
            background-image: linear-gradient(45deg, #88d4ab, #62b398); /* í˜¸ë²„ ì‹œ ìƒ‰ìƒ ë³€ê²½ */
            transform: translateY(-4px) scale(1.02); /* ì‚´ì§ ì»¤ì§€ë©´ì„œ ìœ„ë¡œ */
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.25);
        }
        .difficulty-buttons button:active, 
        .game-selection-buttons button:active,
        #memory-restart-button:active, #memory-home-button:active,
        #reaction-restart-button:active, #reaction-home-button:active,
        .gugudan-option-button:active,
        #gugudan-restart-button:active, #gugudan-home-button:active
        {
            transform: translateY(0px) scale(1); /* ì›ë˜ í¬ê¸°ë¡œ ëŒì•„ì˜¤ë©´ì„œ ì•„ë˜ë¡œ */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        /* ê²Œì„ í™”ë©´ ê³µí†µ ìŠ¤íƒ€ì¼ */
        .game-screen-common {
            justify-content: flex-start;
            padding-top: 25px; /* íŒ¨ë”© ì¦ê°€ */
            width: 100%;
            box-sizing: border-box;
        }

        .game-screen-common h2 {
            color: #6a0dad; /* ë³´ë¼ìƒ‰ ê³„ì—´ë¡œ ë³€ê²½ */
            margin-bottom: 25px; /* ë§ˆì§„ ì¦ê°€ */
            font-size: 2em; /* í°íŠ¸ í¬ê¸° ì¦ê°€ */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.05);
        }

        /* ìˆœë°œë ¥ ê²Œì„ ì œëª© h2 ìˆ¨ê¸°ê¸° */
        #reaction-game-title {
            display: none;
        }

        .game-canvas-common {
            display: block;
            background-color: #f4f8f9; /* ë” ë°ì€ ë°°ê²½ìƒ‰ */
            border-radius: 15px; /* ë‘¥ê·¼ ëª¨ì„œë¦¬ ì¦ê°€ */
            box-shadow: inset 0 3px 8px rgba(0, 0, 0, 0.1); /* ê·¸ë¦¼ì ê°•í™” */
            margin: 0 auto 25px auto; /* ë§ˆì§„ ì¦ê°€ */
            max-width: calc(100% - 50px); /* íŒ¨ë”© ê³ ë ¤ ë„ˆë¹„ ì¡°ì ˆ */
            touch-action: manipulation;
        }

        .game-info-common {
            margin-top: auto;
            padding: 15px 25px 25px 25px; /* íŒ¨ë”© ì¦ê°€ */
            width: 100%;
            box-sizing: border-box;
            display: flex;
            /* ë¬¸êµ¬ê°€ ì—†ì–´ì ¸ì„œ ë²„íŠ¼ë§Œ ë‚¨ìœ¼ë¯€ë¡œ ê°€ìš´ë° ì •ë ¬ë¡œ ë³€ê²½ */
            justify-content: center; 
            align-items: center;
            flex-wrap: wrap;
            gap: 12px; /* ê°„ê²© ì¦ê°€ */
        }

        .game-info-common p {
            font-size: 1.3em; /* í°íŠ¸ í¬ê¸° ì¦ê°€ */
            font-weight: bold;
            color: #555;
            margin: 0;
        }

        /* ì´ì „ "ë’¤ì§‘ì€ ì¹´ë“œ" ë¬¸êµ¬ ê´€ë ¨ CSSëŠ” ë” ì´ìƒ í•„ìš” ì—†ìœ¼ë¯€ë¡œ ì‚­ì œ */
        /* #memory-game-screen .game-info-common p:first-child {
            margin-left: 20px;
        } */

        .game-buttons-common {
            display: flex;
            gap: 12px; /* ê°„ê²© ì¦ê°€ */
            margin-top: 0; /* ë¬¸êµ¬ê°€ ì‚¬ë¼ì§€ë©´ì„œ ê¸°ë³¸ ë§ˆì§„ ì œê±° (í•„ìš”ì— ë”°ë¼ ì¡°ì ˆ) */
            width: 100%;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* ìˆœë°œë ¥ ê²Œì„ í”Œë ˆì´ ì˜ì—­ */
        #reaction-game-play-area {
            display: none; 
            flex-direction: column;
            align-items: center;
            width: 100%;
            position: relative; /* ì˜¤ë²„ë ˆì´ë¥¼ ì´ ìš”ì†Œ ê¸°ì¤€ìœ¼ë¡œ ì ˆëŒ€ ìœ„ì¹˜ì‹œí‚¤ê¸° ìœ„í•´ ì¶”ê°€ */
        }

        /* ìˆœë°œë ¥ ê²Œì„ - ì‹œì‘ ì „ ì˜¤ë²„ë ˆì´ (ì•ˆë‚´ & ì¹´ìš´íŠ¸ë‹¤ìš´) */
        #reaction-pre-game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.95); /* ë” ë¶ˆíˆ¬ëª…í•˜ê²Œ */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            /* ê¸°ë³¸ í°íŠ¸ í¬ê¸° ìœ ì§€ */
            font-size: 2.8em; 
            font-weight: bold;
            color: #333;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.15);
            border-radius: 15px; /* ë‘¥ê·¼ ëª¨ì„œë¦¬ ì¦ê°€ */
            display: none; 
        }

        #reaction-instruction-text {
            /* ê¸°ì¡´ font-size: 0.8em; ì—ì„œ ì ˆë°˜ì¸ 0.4emë¡œ ë³€ê²½ */
            font-size: 0.4em; /* ì•ˆë‚´ ê¸€ì í¬ê¸° ì¡°ì • */
            margin-bottom: 25px; /* ë§ˆì§„ ì¦ê°€ */
            color: #4CAF50; /* ìƒ‰ìƒ ìœ ì§€ */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px; /* ê°„ê²© ì¦ê°€ */
        }
        #reaction-instruction-text .emoji-display {
            font-size: 3.5em; /* ì´ëª¨ì§€ í¬ê¸° ì¦ê°€ */
        }

        #reaction-countdown-text {
            font-size: 3em; /* 'ì‹œì‘!' ê¸€ì í¬ê¸° ì¦ê°€ */
            color: #8A2BE2; /* ë³´ë¼ìƒ‰ ê³„ì—´ë¡œ ë³€ê²½ */
            text-shadow: 2px 2px 5px rgba(0,0,0,0.25);
        }

        /* êµ¬êµ¬ë‹¨ ê²Œì„ ìŠ¤íƒ€ì¼ */
        #gugudan-question-number {
            font-size: 1.3em;
            font-weight: bold;
            color: #555;
            margin-bottom: 15px;
            margin-top: 10px; /* ìƒë‹¨ì— ì¢€ ë” ì—¬ìœ  ê³µê°„ */
        }

        #gugudan-problem {
            font-size: 3em; /* ë¬¸ì œ ê¸€ì í¬ê¸° */
            color: #6a0dad;
            margin-bottom: 30px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.05);
        }
        
        /* êµ¬êµ¬ë‹¨ ë³´ê¸° ë²„íŠ¼ ì»¨í…Œì´ë„ˆ */
        #gugudan-options {
            display: flex;
            flex-direction: row; /* 2x2 ë ˆì´ì•„ì›ƒì„ ìœ„í•´ ëª…ì‹œì ìœ¼ë¡œ row ì„¤ì • */
            flex-wrap: wrap; /* ë²„íŠ¼ì´ ë‹¤ìŒ ì¤„ë¡œ ë„˜ì–´ê°ˆ ìˆ˜ ìˆë„ë¡ í—ˆìš© */
            justify-content: center; /* ê°€ë¡œ ì¤‘ì•™ ì •ë ¬ */
            gap: 15px; /* ë²„íŠ¼ ì‚¬ì´ ê°„ê²© */
            width: 90%; /* ë¶€ëª¨ì— ë”°ë¼ ë„ˆë¹„ ì¡°ì ˆ */
            max-width: 400px; /* ìµœëŒ€ ë„ˆë¹„ ì„¤ì • */
            margin-bottom: 30px; /* ì•„ë˜ ì—¬ë°± ì¶”ê°€ */
        }

        /* êµ¬êµ¬ë‹¨ ë³´ê¸° ë²„íŠ¼ ê°œë³„ ìŠ¤íƒ€ì¼ */
        .gugudan-option-button {
            flex: 1 1 calc(50% - 15px); /* í•œ ì¤„ì— ë‘ ê°œì”© (ê°„ê²© ê³ ë ¤) */
            max-width: calc(50% - 15px); /* ìµœëŒ€ ë„ˆë¹„ë¡œ ê°•ì œ */
            box-sizing: border-box; /* íŒ¨ë”©, ë³´ë”ê°€ ë„ˆë¹„ì— í¬í•¨ë˜ë„ë¡ */
            padding: 20px; /* íŒ¨ë”© ì¦ê°€ */
            font-size: 1.8em; /* í°íŠ¸ í¬ê¸° ì¦ê°€ */
            background-image: linear-gradient(45deg, #a7e9af, #88d4ab); /* ì—°ë‘ìƒ‰ ê·¸ë¼ë°ì´ì…˜ */
            border-radius: 12px; /* ëª¨ì„œë¦¬ ë‘¥ê¸€ê²Œ */
        }

        /* í´ë¦­ í”¼ë“œë°± í…ìŠ¤íŠ¸ë¥¼ ìœ„í•œ ìŠ¤íƒ€ì¼ */
        .gugudan-feedback-text {
            position: absolute;
            font-size: 2.2em; /* í”¼ë“œë°± í…ìŠ¤íŠ¸ í¬ê¸° */
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            transform: translateY(0px);
            pointer-events: none; /* í´ë¦­ ì´ë²¤íŠ¸ ë¬´ì‹œ */
            z-index: 10; /* ë‹¤ë¥¸ ìš”ì†Œ ìœ„ì— í‘œì‹œ */
            white-space: nowrap; /* í…ìŠ¤íŠ¸ ì¤„ë°”ê¿ˆ ë°©ì§€ */
        }
        /* ì»¤ìŠ¤í…€ ëª¨ë‹¬ ìŠ¤íƒ€ì¼ */
        .custom-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6); /* ë°°ê²½ ë” ì–´ë‘¡ê²Œ */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: #fff;
            padding: 35px; /* íŒ¨ë”© ì¦ê°€ */
            border-radius: 20px; /* ë‘¥ê·¼ ëª¨ì„œë¦¬ ì¦ê°€ */
            text-align: center;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.25); /* ê·¸ë¦¼ì ê°•í™” */
            max-width: 85%; /* ìµœëŒ€ ë„ˆë¹„ ì¦ê°€ */
            animation: fadeInScale 0.3s ease-out; /* ëª¨ë‹¬ ë“±ì¥ ì• ë‹ˆë©”ì´ì…˜ */
        }
        
        @keyframes fadeInScale {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        .modal-content h3 {
            color: #6a0dad; /* ë³´ë¼ìƒ‰ ê³„ì—´ë¡œ ë³€ê²½ */
            font-size: 1.8em; /* í°íŠ¸ í¬ê¸° ì¦ê°€ */
            margin-bottom: 15px;
        }

        .modal-content p {
            font-size: 1.6em; /* í°íŠ¸ í¬ê¸° ì¦ê°€ */
            margin-bottom: 25px; /* ë§ˆì§„ ì¦ê°€ */
            color: #555;
            line-height: 1.4; /* ì¤„ ê°„ê²© ì¡°ì ˆ */
        }

        .modal-close-button {
            padding: 15px 30px; /* íŒ¨ë”© ì¦ê°€ */
            font-size: 1.2em; /* í°íŠ¸ í¬ê¸° ì¦ê°€ */
            font-weight: bold;
            color: #fff;
            /* ëª¨ë‹¬ ë²„íŠ¼ë„ íŒŒìŠ¤í…” ê·¸ë¼ë°ì´ì…˜ */
            background-image: linear-gradient(45deg, #87ceeb, #add8e6); /* ì—°í•œ íŒŒë‘ ê·¸ë¼ë°ì´ì…˜ */
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
        }

        .modal-close-button:hover {
            background-image: linear-gradient(45deg, #6bbde2, #87ceeb); /* í˜¸ë²„ ì‹œ ìƒ‰ìƒ ë³€ê²½ */
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
        }
        /* CSS ë */
    </style>
</head>
<body>
    <div id="app">
        <!-- í™ˆ í™”ë©´ -->
        <div id="home-screen" class="screen active">
            <h1>ì¬ë¯¸ìˆëŠ” ë‘ë‡Œ ê²Œì„</h1>
            <p>ì›í•˜ëŠ” ê²Œì„ì„ ì„ íƒí•´ ì£¼ì„¸ìš”!</p>
            <div class="game-selection-buttons">
                <button data-game-type="memory">ê¸°ì–µë ¥ ì‘¥ì‘¥ ì¹´ë“œ ë’¤ì§‘ê¸°</button>
                <button data-game-type="reaction">ìˆœë°œë ¥ ë²ˆì© ì¹´ë“œ í´ë¦­</button>
                <button data-game-type="gugudan">êµ¬êµ¬ë‹¨ ê²Œì„</button> <!-- êµ¬êµ¬ë‹¨ ê²Œì„ ë²„íŠ¼ ì¶”ê°€ -->
            </div>
        </div>

        <!-- ê¸°ì–µë ¥ ê²Œì„ í™”ë©´ -->
        <div id="memory-game-screen" class="screen game-screen-common">
            <h2 id="memory-game-title"></h2>
            <div class="difficulty-buttons">
                <button data-difficulty="easy">ê°€ì¥ ì‰¬ì›€</button>
                <button data-difficulty="medium">ì¤‘ê°„</button>
                <button data-difficulty="hard">ì–´ë ¤ì›€</button>
            </div>
            <!-- ìº”ë²„ìŠ¤ëŠ” ë‚œì´ë„ ì„ íƒ í›„ ë™ì ìœ¼ë¡œ ì„¤ì •ë¨ -->
            <canvas id="memory-game-canvas" class="game-canvas-common"></canvas>
            <div class="game-info-common">
                <!-- 'ë’¤ì§‘ì€ ì¹´ë“œ' ë¬¸êµ¬ê°€ ì—¬ê¸°ì„œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤. -->
                <div class="game-buttons-common">
                    <button id="memory-restart-button">ë‹¤ì‹œ ì‹œì‘</button>
                    <button id="memory-home-button">í™ˆìœ¼ë¡œ</button>
                </div>
            </div>
        </div>

        <!-- ìˆœë°œë ¥ ê²Œì„ í™”ë©´ -->
        <div id="reaction-game-screen" class="screen game-screen-common">
            <h2 id="reaction-game-title"></h2> <!-- ì´ H2 íƒœê·¸ì˜ ë‚´ìš©ì´ CSSë¡œ ìˆ¨ê²¨ì§‘ë‹ˆë‹¤. -->
            <!-- ìˆœë°œë ¥ ê²Œì„ ë‚œì´ë„ ë²„íŠ¼ -->
            <div class="difficulty-buttons" id="reaction-difficulty-selection">
                <button data-difficulty="easy">ì‰¬ì›€</button>
                <button data-difficulty="medium">ë³´í†µ</button>
                <button data-difficulty="hard">ì–´ë ¤ì›€</button>
            </div>
            <!-- ìˆœë°œë ¥ ê²Œì„ í”Œë ˆì´ ì˜ì—­ -->
            <div id="reaction-game-play-area">
                <canvas id="reaction-game-canvas" class="game-canvas-common"></canvas>
                <!-- ì‹œì‘ ì „ ì•ˆë‚´ ë° ì¹´ìš´íŠ¸ë‹¤ìš´ ì˜¤ë²„ë ˆì´ -->
                <div id="reaction-pre-game-overlay">
                    <div id="reaction-instruction-text">
                        <span class="emoji-display">â­</span>
                        <span>ë³„ ëª¨ì–‘ë§Œ ëˆŒëŸ¬ì£¼ì„¸ìš”!</span>
                    </div>
                    <div id="reaction-countdown-text" style="display:none;"></div>
                </div>
                <div class="game-info-common">
                    <p>ì„±ê³µ: <span id="reaction-score">0</span> / ëª©í‘œ: <span id="reaction-target-clicks">20</span></p>
                    <p>ì‹œë„: <span id="reaction-attempts">0</span></p>
                    <div class="game-buttons-common">
                        <button id="reaction-restart-button">ë‹¤ì‹œ ì‹œì‘</button>
                        <button id="reaction-home-button">í™ˆìœ¼ë¡œ</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- êµ¬êµ¬ë‹¨ ê²Œì„ í™”ë©´ -->
        <div id="gugudan-game-screen" class="screen game-screen-common">
            <p id="gugudan-question-number">ë¬¸ì œ 1/20</p>
            <h2 id="gugudan-problem"></h2>
            <!-- êµ¬êµ¬ë‹¨ í”¼ë“œë°± í…ìŠ¤íŠ¸ëŠ” ì´ì œ ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤. -->
            <div id="gugudan-options" class="game-buttons">
                <button class="gugudan-option-button"></button>
                <button class="gugudan-option-button"></button>
                <button class="gugudan-option-button"></button>
                <button class="gugudan-option-button"></button>
            </div>
            <div class="game-info-common">
                <div class="game-buttons-common">
                    <button id="gugudan-restart-button">ë‹¤ì‹œ ì‹œì‘</button>
                    <button id="gugudan-home-button">í™ˆìœ¼ë¡œ</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // JavaScript ì‹œì‘

        // --- DOM ìš”ì†Œ ê°€ì ¸ì˜¤ê¸° ---
        const homeScreen = document.getElementById('home-screen');
        const gameSelectionButtons = document.querySelector('.game-selection-buttons');

        // ê¸°ì–µë ¥ ê²Œì„ ìš”ì†Œ
        const memoryGameScreen = document.getElementById('memory-game-screen');
        const memoryDifficultyButtons = memoryGameScreen.querySelector('.difficulty-buttons');
        const memoryGameTitle = document.getElementById('memory-game-title');
        const memoryGameCanvas = document.getElementById('memory-game-canvas');
        const memoryCtx = memoryGameCanvas.getContext('2d');
        const memoryRestartButton = document.getElementById('memory-restart-button');
        const memoryHomeButton = document.getElementById('memory-home-button');
        const memoryGameInfo = memoryGameScreen.querySelector('.game-info-common'); // ìƒˆë¡œ ì¶”ê°€: ê¸°ì–µë ¥ ê²Œì„ ì •ë³´ ì„¹ì…˜

        // ìˆœë°œë ¥ ê²Œì„ ìš”ì†Œ
        const reactionGameScreen = document.getElementById('reaction-game-screen');
        const reactionDifficultyButtons = document.getElementById('reaction-difficulty-selection'); // idë¡œ ê°€ì ¸ì˜´
        const reactionGamePlayArea = document.getElementById('reaction-game-play-area'); // ìƒˆë¡œìš´ ìš”ì†Œ
        const reactionGameTitle = document.getElementById('reaction-game-title');
        const reactionGameCanvas = document.getElementById('reaction-game-canvas');
        const reactionCtx = reactionGameCanvas.getContext('2d');
        const reactionRestartButton = document.getElementById('reaction-restart-button');
        const reactionHomeButton = document.getElementById('reaction-home-button');
        const reactionScoreSpan = document.getElementById('reaction-score');
        const reactionTargetClicksSpan = document.getElementById('reaction-target-clicks');
        const reactionAttemptsSpan = document.getElementById('reaction-attempts');
        const reactionPreGameOverlay = document.getElementById('reaction-pre-game-overlay'); // ìƒˆë¡œìš´ ì˜¤ë²„ë ˆì´
        const reactionInstructionText = document.getElementById('reaction-instruction-text');
        const reactionCountdownText = document.getElementById('reaction-countdown-text');
        const reactionGameInfo = reactionGameScreen.querySelector('.game-info-common'); // ëˆ„ë½ëœ ì„ ì–¸ ì¶”ê°€

        // êµ¬êµ¬ë‹¨ ê²Œì„ ìš”ì†Œ
        const gugudanGameScreen = document.getElementById('gugudan-game-screen');
        const gugudanQuestionNumberDisplay = document.getElementById('gugudan-question-number');
        const gugudanProblemDisplay = document.getElementById('gugudan-problem');
        const gugudanOptionsContainer = document.getElementById('gugudan-options');
        const gugudanOptionButtons = gugudanOptionsContainer.querySelectorAll('.gugudan-option-button');
        const gugudanRestartButton = document.getElementById('gugudan-restart-button');
        const gugudanHomeButton = document.getElementById('gugudan-home-button');
        // const gugudanFeedbackDisplay = document.getElementById('gugudan-feedback'); // ì´ì œ ë™ì ìœ¼ë¡œ ìƒì„±ë˜ë¯€ë¡œ ì£¼ì„ ì²˜ë¦¬ ë˜ëŠ” ì‚­ì œ

        // --- ê³µí†µ ê²Œì„ ì„¤ì • ë³€ìˆ˜ ---
        let currentActiveGameType = null; // 'memory', 'reaction' ë˜ëŠ” 'gugudan'
        const CANVAS_HORIZONTAL_PADDING = 20; // ìº”ë²„ìŠ¤ ì™¸ë¶€ ì¢Œìš° íŒ¨ë”©

        // ì¹´ë“œ ìƒìˆ˜ (ìº”ë²„ìŠ¤ ê·¸ë¦¬ê¸°ìš©)
        const CARD_COLOR_BACK = '#555';
        const CARD_COLOR_FRONT = '#f0f0f0';
        const CARD_TEXT_COLOR = '#333';
        const CARD_BORDER_COLOR = '#333';
        const CARD_ROUND_RADIUS = 8;

        // ìˆœë°œë ¥ ê²Œì„ ì „ìš© ì¹´ë“œ ìƒ‰ìƒ ë° ì•„ì´ì½˜ (íŒŒìŠ¤í…”í†¤ìœ¼ë¡œ ë³€ê²½)
        const STAR_EMOJI = 'â­';
        const SUPER_STAR_EMOJI = 'âœ¨'; 
        const BOMB_EMOJI = 'ğŸ’£'; // í­íƒ„ ì´ëª¨ì§€ë¡œ ë³€ê²½
        const TARGET_CARD_COLOR_STAR = '#FFECB3'; // ì—°í•œ ë…¸ë‘ (íŒŒìŠ¤í…”í†¤)
        const TARGET_TEXT_COLOR_STAR = '#FFA000'; // ì£¼í™©ìƒ‰ (ëŒ€ë¹„)
        const TARGET_CARD_COLOR_SUPER_STAR = '#B3E5FC'; // ì—°í•œ íŒŒë‘ (íŒŒìŠ¤í…”í†¤)
        const TARGET_TEXT_COLOR_SUPER_STAR = '#03A9F4'; // ì§„í•œ íŒŒë‘ (ëŒ€ë¹„)
        const TARGET_CARD_COLOR_BOMB = '#FFCDD2'; // ì—°í•œ ë¹¨ê°• (íŒŒìŠ¤í…”í†¤)
        const TARGET_TEXT_COLOR_BOMB = '#D32F2F'; // ì§„í•œ ë¹¨ê°• (ëŒ€ë¹„)

        const CLICK_PADDING_PIXELS = 15; // ìˆœë°œë ¥ ê²Œì„ í´ë¦­ íŒì • ì˜ì—­ í™•ì¥ (í”½ì…€)

        // ìˆœë°œë ¥ ê²Œì„ ì‹œì‘ ì „ ì• ë‹ˆë©”ì´ì…˜ ì‹œê°„
        const REACTION_INSTRUCTION_DURATION = 2000; // 2ì´ˆ (ì•ˆë‚´ ë©”ì‹œì§€)
        const REACTION_COUNTDOWN_DURATION = 3000; // 3ì´ˆ (3-2-1 ì¹´ìš´íŠ¸ë‹¤ìš´)
        const MAX_CONSECUTIVE_BOMBS = 3; // í­íƒ„ ìµœëŒ€ ì—°ì† ì¶œí˜„ íšŸìˆ˜

        // --- ê¸°ì–µë ¥ ê²Œì„ ë³€ìˆ˜ ë° ì„¤ì • ---
        let memoryCards = [];
        let memoryFlippedCards = [];
        let memoryMatchedPairs = 0;
        let memoryTotalFlips = 0;
        let memoryLockBoard = false;

        const memoryDifficulties = {
            easy: { cols: 3, rows: 4, totalCards: 12, title: 'ê¸°ì–µë ¥ ì‘¥ì‘¥ - ê°€ì¥ ì‰¬ì›€' },
            medium: { cols: 4, rows: 4, totalCards: 16, title: 'ê¸°ì–µë ¥ ì‘¥ì‘¥ - ì¤‘ê°„' },
            hard: { cols: 4, rows: 5, totalCards: 20, title: 'ê¸°ì–µë ¥ ì‘¥ì‘¥ - ì–´ë ¤ì›€' }
        };
        let currentMemoryDifficulty = null;

        // ì‰¬ì›€ ë° ì–´ë ¤ì›€ ë‚œì´ë„ì—ì„œ ìº”ë²„ìŠ¤ ë†’ì´ ê°ì†Œë¥¼ ìœ„í•œ ìƒìˆ˜
        const BUTTON_VISIBILITY_REDUCTION = 50; 

        // --- ìˆœë°œë ¥ ê²Œì„ ë³€ìˆ˜ ë° ì„¤ì • ---
        let reactionScore = 0;
        let reactionAttempts = 0;
        let reactionTargetCard = null; // { type: 'star'/'superStar'/'bomb', x, y, width, height, value }
        let reactionTargetVisibleTimer = null;
        let reactionGameInterval = null;
        let consecutiveBombs = 0; // ì—°ì† í­íƒ„ ì¹´ìš´í„°
        let floatingTexts = []; // í´ë¦­ ì‹œ í‘œì‹œë˜ëŠ” +1/-1 í…ìŠ¤íŠ¸ ë°°ì—´
        let reactionAnimationLoopId = null; // ìˆœë°œë ¥ ê²Œì„ ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ID

        const REACTION_CLICKS_NEEDED = 20; // ìˆœë°œë ¥ ê²Œì„ ì„±ê³µ ëª©í‘œ

        const reactionDifficulties = {
            easy: { cols: 3, rows: 4, title: 'ìˆœë°œë ¥ ë²ˆì© - ì‰¬ì›€', interval: 1200, duration: 800 },
            medium: { cols: 4, rows: 4, title: 'ìˆœë°œë ¥ ë²ˆì© - ë³´í†µ', interval: 900, duration: 600 },
            hard: { cols: 4, rows: 5, title: 'ìˆœë°œë ¥ ë²ˆì© - ì–´ë ¤ì›€', interval: 700, duration: 500 }
        };
        let currentReactionDifficulty = null;

        // --- êµ¬êµ¬ë‹¨ ê²Œì„ ë³€ìˆ˜ ë° ì„¤ì • ---
        let gugudanQuestions = [];
        let currentGugudanQuestionIndex = 0;
        let gugudanScore = 0;
        const TOTAL_GUGUDAN_QUESTIONS = 20;

        // --- Tone.js Sound Synthesisers ---
        let initializedAudio = false; // ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™” ì—¬ë¶€

        // ê³µí†µ í´ë¦­ ì‚¬ìš´ë“œ (ê²Œì„ ì„ íƒ, ë‚œì´ë„ ë²„íŠ¼)
        const clickSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "triangle" }, // Changed to triangle for softer tone
            envelope: { attack: 0.005, decay: 0.05, sustain: 0, release: 0.05 } // Shorter, percussive envelope
        }).toDestination();

        // ë³„ í´ë¦­ ì‚¬ìš´ë“œ (ë”©ë™)
        const starClickSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "sine" },
            envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 }
        }).toDestination();

        // í­íƒ„ í´ë¦­ ì‚¬ìš´ë“œ (ë™ë”©) - ì˜¤ë‹µ ì‚¬ìš´ë“œë¡œ ì¬í™œìš©
        const bombClickSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "sawtooth" },
            envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 }
        }).toDestination();

        // ê²Œì„ ì¢…ë£Œ ì‚¬ìš´ë“œ (ì§œì”~)
        const gameEndSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "triangle" },
            envelope: { attack: 0.05, decay: 0.3, sustain: 0.1, release: 0.5 }
        }).toDestination();

        // ì¹´ë“œ ë’¤ì§‘ê¸° ì‚¬ìš´ë“œ (ì‚­ì‚­ì‚­)
        const cardFlipSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "square" },
            envelope: { attack: 0.005, decay: 0.02, sustain: 0.01, release: 0.05 }
        }).toDestination();
        
        // ì¹´ìš´íŠ¸ë‹¤ìš´ ì‚¬ìš´ë“œ (ë”§ ë”§ ë”§ ë ì´!!!!)
        const countdownSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "sine" },
            envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 }
        }).toDestination();


        // --- Sound Playback Functions ---
        function playClickSound() {
            if (!initializedAudio) Tone.start();
            clickSynth.triggerAttackRelease("C5", "32n"); // Single, very short high note
        }

        function playStarClickSound() { // ì •ë‹µ ì‚¬ìš´ë“œë¡œ ì¬í™œìš©
            if (!initializedAudio) Tone.start();
            starClickSynth.triggerAttackRelease(["C5", "G5"], "8n"); // ë”©ë™
        }

        function playBombClickSound() { // ì˜¤ë‹µ ì‚¬ìš´ë“œë¡œ ì¬í™œìš©
            if (!initializedAudio) Tone.start();
            bombClickSynth.triggerAttackRelease(["G4", "C4"], "8n"); // ë™ë”©
        }

        function playMemoryFlipSound() {
            if (!initializedAudio) Tone.start();
            cardFlipSynth.triggerAttackRelease(["C4", "D4", "E4"], "16n", Tone.now()); // ì‚­ì‚­ì‚­
        }

        function playTaDaSound() {
            if (!initializedAudio) Tone.start();
            gameEndSynth.triggerAttackRelease(["C5", "E5", "G5"], "2n"); // ì§œì”~
        }

        function playCountdownSound(note, duration = "8n") {
            if (!initializedAudio) Tone.start();
            countdownSynth.triggerAttackRelease(note, duration);
        }


        // --- ê³µí†µ í™”ë©´ ì „í™˜ í•¨ìˆ˜ ---
        function showScreen(screenId) {
            const screens = document.querySelectorAll('.screen');
            screens.forEach(screen => screen.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }

        // --- ê¸°ì–µë ¥ ê²Œì„ í•¨ìˆ˜ ---

        /**
         * ê¸°ì–µë ¥ ê²Œì„ ì‹œì‘ í•¨ìˆ˜.
         * @param {string} difficultyKey - ì„ íƒëœ ë‚œì´ë„ í‚¤ ('easy', 'medium', 'hard')
         */
        function startMemoryGame(difficultyKey) {
            playClickSound(); // ê²Œì„ ì‹œì‘ ë²„íŠ¼ í´ë¦­ ì†Œë¦¬
            currentActiveGameType = 'memory';
            currentMemoryDifficulty = memoryDifficulties[difficultyKey];
            
            // ë‚œì´ë„ ë²„íŠ¼ì„ ìˆ¨ê¸°ê³  ìº”ë²„ìŠ¤ë¥¼ ë³´ì´ë„ë¡ ë³€ê²½
            memoryDifficultyButtons.style.display = 'none'; 
            memoryGameCanvas.style.display = 'block'; // ìº”ë²„ìŠ¤ ë³´ì´ê¸°
            memoryGameInfo.style.display = 'flex'; // ê²Œì„ ì •ë³´ í‘œì‹œ

            // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì • (ë°˜ì‘í˜•)
            const appHeight = document.getElementById('app').clientHeight;
            const appWidth = document.getElementById('app').clientWidth;
            const screenPaddingTop = 25; // .game-screen-commonì˜ padding-top

            // game-info-commonì´ display:flex ìƒíƒœì¼ ë•Œ ë†’ì´ë¥¼ ì •í™•íˆ ì¸¡ì •
            const originalGameInfoDisplay = memoryGameInfo.style.display;
            memoryGameInfo.style.display = 'flex'; // ì¼ì‹œì ìœ¼ë¡œ flexë¡œ ì„¤ì •í•˜ì—¬ offsetHeightê°€ ì •í™•íˆ ê³„ì‚°ë˜ë„ë¡ í•¨
            const gameInfoHeight = memoryGameInfo.offsetHeight;
            memoryGameInfo.style.display = originalGameInfoDisplay; // ì›ë˜ display ìƒíƒœë¡œ ë³µì›

            const canvasMarginBottom = 25; // .game-canvas-commonì˜ margin-bottom

            // ìº”ë²„ìŠ¤ê°€ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ìµœëŒ€ ìˆ˜ì§ ê³µê°„ ê³„ì‚°
            let availableVerticalSpaceForCanvas = appHeight - screenPaddingTop - gameInfoHeight - canvasMarginBottom;
            
            // ì‰¬ì›€ ë° ì–´ë ¤ì›€ ë‚œì´ë„ì—ì„œë§Œ ìº”ë²„ìŠ¤ ë†’ì´ ì¶”ê°€ ê°ì†Œ
            if (difficultyKey === 'easy' || difficultyKey === 'hard') {
                availableVerticalSpaceForCanvas -= BUTTON_VISIBILITY_REDUCTION;
            }

            const canvasRenderWidth = appWidth - (2 * CANVAS_HORIZONTAL_PADDING);
            
            const cardSpacing = 10;
            const tempCols = currentMemoryDifficulty.cols; 
            const tempRows = currentMemoryDifficulty.rows; 

            // ìº”ë²„ìŠ¤ ë„ˆë¹„ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì´ìƒì ì¸ ì¹´ë“œ í¬ê¸° ê³„ì‚°
            const idealCardWidth = (canvasRenderWidth - ((tempCols - 1) * cardSpacing)) / tempCols;
            const idealCardHeight = idealCardWidth; 

            // ì´ìƒì ì¸ ì¹´ë“œ í¬ê¸°ë¡œ ê·¸ë¦¬ë“œë¥¼ ë§Œë“¤ì—ˆì„ ë•Œ í•„ìš”í•œ ìº”ë²„ìŠ¤ ë†’ì´
            let idealCanvasHeight = (tempRows * idealCardHeight) + ((tempRows - 1) * cardSpacing);

            let finalCanvasWidth = canvasRenderWidth;
            let finalCanvasHeight;

            // ì´ìƒì ì¸ ìº”ë²„ìŠ¤ ë†’ì´ê°€ ì‚¬ìš© ê°€ëŠ¥í•œ ìˆ˜ì§ ê³µê°„ì„ ì´ˆê³¼í•˜ëŠ” ê²½ìš°, ë†’ì´ì— ë§ì¶° ì¹´ë“œ í¬ê¸° ì¡°ì •
            if (idealCanvasHeight > availableVerticalSpaceForCanvas) {
                finalCanvasHeight = availableVerticalSpaceForCanvas;
                const newCardHeight = (finalCanvasHeight - ((tempRows - 1) * cardSpacing)) / tempRows;
                const newCardWidth = newCardHeight; // ì¢…íš¡ë¹„ ìœ ì§€
                finalCanvasWidth = (tempCols * newCardWidth) + ((tempCols - 1) * cardSpacing);
            } else {
                finalCanvasHeight = idealCanvasHeight;
            }

            // ìº”ë²„ìŠ¤ ìµœì¢… í¬ê¸° ì„¤ì •
            memoryGameCanvas.width = finalCanvasWidth;
            memoryGameCanvas.height = finalCanvasHeight;

            createMemoryCards();
            shuffleMemoryCards();
            resetMemoryGameState(); // currentMemoryDifficultyê°€ ì„¤ì •ëœ í›„ í˜¸ì¶œ
            drawMemoryGame();

            // showScreen('memory-game-screen'); // ì´ë¯¸ í•´ë‹¹ í™”ë©´ì´ë¯€ë¡œ ì£¼ì„ ì²˜ë¦¬ ë˜ëŠ” ì œê±°
        }

        function createMemoryCards() {
            memoryCards = [];
            const numPairs = currentMemoryDifficulty.totalCards / 2;
            for (let i = 1; i <= numPairs; i++) {
                memoryCards.push({ value: i, isFlipped: false, isMatched: false, displayRotation: 0 });
                memoryCards.push({ value: i, isFlipped: false, isMatched: false, displayRotation: 0 });
            }
        }

        function shuffleMemoryCards() {
            for (let i = memoryCards.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [memoryCards[i], memoryCards[j]] = [memoryCards[j], memoryCards[i]];
            }
        }

        function resetMemoryGameState() {
            memoryFlippedCards = [];
            memoryMatchedPairs = 0;
            memoryTotalFlips = 0;
            memoryLockBoard = false;
            memoryCards.forEach(card => {
                card.isFlipped = false;
                card.isMatched = false;
                card.displayRotation = 0;
            });
        }

        function drawMemoryGame() {
            memoryCtx.clearRect(0, 0, memoryGameCanvas.width, memoryGameCanvas.height);

            const cardSpacing = 10;
            // ìº”ë²„ìŠ¤ ë„ˆë¹„ì™€ ë†’ì´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì¹´ë“œ ë„ˆë¹„/ë†’ì´ë¥¼ ì¬ê³„ì‚°
            const cardWidth = (memoryGameCanvas.width - ((currentMemoryDifficulty.cols - 1) * cardSpacing)) / currentMemoryDifficulty.cols;
            const cardHeight = (memoryGameCanvas.height - ((currentMemoryDifficulty.rows - 1) * cardSpacing)) / currentMemoryDifficulty.rows;

            memoryCards.forEach((card, index) => {
                const col = index % currentMemoryDifficulty.cols;
                const row = Math.floor(index / currentMemoryDifficulty.cols);

                // ì¹´ë“œì˜ ì‹¤ì œ ê·¸ë ¤ì§ˆ ìœ„ì¹˜ ë° í¬ê¸° ê³„ì‚° (ì¡°ì •ëœ ìº”ë²„ìŠ¤ í¬ê¸° ë°˜ì˜)
                card.x = col * (cardWidth + cardSpacing);
                card.y = row * (cardHeight + cardSpacing);
                card.width = cardWidth;
                card.height = cardHeight;

                drawCard(memoryCtx, card, CARD_COLOR_BACK, CARD_COLOR_FRONT, CARD_TEXT_COLOR, CARD_BORDER_COLOR);
            });
        }

        /**
         * ì¹´ë“œ ê·¸ë¦¬ê¸° (ê³µí†µ í•¨ìˆ˜)
         * @param {CanvasRenderingContext2D} context - ê·¸ë¦´ ìº”ë²„ìŠ¤ ì»¨í…ìŠ¤íŠ¸
         * @param {object} card - ì¹´ë“œ ê°ì²´ (value, x, y, width, height, isMatched, displayRotation, type)
         * @param {string} backColor - ë’·ë©´ ìƒ‰ìƒ
         * @param {string} frontColor - ì•ë©´ ìƒ‰ìƒ
         * @param {string} textColor - í…ìŠ¤íŠ¸ ìƒ‰ìƒ
         * @param {string} borderColor - í…Œë‘ë¦¬ ìƒ‰ìƒ
         */
        function drawCard(context, card, backColor, frontColor, textColor, borderColor) {
            const { x, y, width, height, value, isMatched, displayRotation, type } = card; // card.type ì¶”ê°€

            if (isMatched) {
                return;
            }

            context.save();
            context.translate(x + width / 2, y + height / 2);
            context.rotate(displayRotation * Math.PI / 180);

            let fillColor = backColor;
            // ìˆœë°œë ¥ ê²Œì„ì˜ ê²½ìš° í•­ìƒ ì•ë©´ìœ¼ë¡œ í‘œì‹œë˜ì§€ë§Œ, ì• ë‹ˆë©”ì´ì…˜ ë¡œì§ì„ ìœ„í•´ rotation ì‚¬ìš©
            if (displayRotation > 90 || type === 'star' || type === 'superStar' || type === 'bomb') { // card.typeìœ¼ë¡œ ë³€ê²½
                fillColor = frontColor;
            }

            context.fillStyle = fillColor;
            roundRect(context, -width / 2, -height / 2, width, height, CARD_ROUND_RADIUS);
            context.fill();

            context.strokeStyle = borderColor;
            context.lineWidth = 2;
            roundRect(context, -width / 2, -height / 2, width, height, CARD_ROUND_RADIUS);
            context.stroke();

            // ë©”ëª¨ë¦¬ ê²Œì„ ì¹´ë“œì´ê±°ë‚˜, ìˆœë°œë ¥ ê²Œì„ì˜ íƒ€ê²Ÿ ì¹´ë“œì¸ ê²½ìš° í…ìŠ¤íŠ¸/ì´ë¯¸ì§€ í‘œì‹œ
            if (card.isFlipped || type === 'star' || type === 'superStar' || type === 'bomb') { // card.typeìœ¼ë¡œ ë³€ê²½
                context.fillStyle = textColor;
                context.textAlign = 'center';
                context.textBaseline = 'middle';

                // ì¹´ë“œì˜ í˜„ì¬ íšŒì „ëŸ‰ì„ ì—­ìœ¼ë¡œ ì ìš©í•˜ì—¬ ê¸€ì”¨ëŠ” í•­ìƒ ë˜‘ë°”ë¡œ ë³´ì´ë„ë¡ í•¨
                if (type === undefined) { // ë©”ëª¨ë¦¬ ì¹´ë“œì¸ ê²½ìš°
                    context.rotate(-displayRotation * Math.PI / 180); 
                    context.font = `${width * 0.4}px 'Segoe UI Emoji', Arial, sans-serif`; /* ì´ëª¨ì§€ ì§€ì› í°íŠ¸ */
                    context.fillText(value, 0, 0);
                } else if (displayRotation > 90) { // ìˆœë°œë ¥ ê²Œì„ ì¹´ë“œ (ì´ë¯¸ í•­ìƒ 180ë„ íšŒì „)
                    context.rotate(180 * Math.PI / 180); // í•­ìƒ ì•ë©´ì´ ìœ„ë¥¼ í–¥í•˜ë„ë¡ ë‹¤ì‹œ íšŒì „

                    if (type === 'bomb') { // í­íƒ„ ì¹´ë“œì¼ ê²½ìš°
                        drawBombShape(context, width * 0.5); // ì¹´ë“œ í¬ê¸°ì— ë¹„ë¡€í•˜ì—¬ í­íƒ„ ê·¸ë¦¬ê¸°
                    } else { // ë³„ ì¹´ë“œì¼ ê²½ìš°
                        context.font = `${width * 0.4}px 'Segoe UI Emoji', Arial, sans-serif`;
                        context.fillText(value, 0, 0);
                    }
                }
            }
            context.restore();
        }

        /**
         * ë‘¥ê·¼ ì‚¬ê°í˜•ì„ ê·¸ë¦¬ëŠ” í—¬í¼ í•¨ìˆ˜
         * @param {CanvasRenderingContext2D} context - ìº”ë²„ìŠ¤ 2D ì»¨í…ìŠ¤íŠ¸
         * @param {number} x - x ì¢Œí‘œ
         * @param {number} y - y ì¢Œí‘œ
         * @param {number} width - ë„ˆë¹„
         * @param {number} height - ë†’ì´
         * @param {number} radius - ë‘¥ê·¼ ëª¨ì„œë¦¬ ë°˜ì§€ë¦„
         */
        function roundRect(context, x, y, width, height, radius) {
            context.beginPath();
            context.moveTo(x + radius, y);
            context.lineTo(x + width - radius, y);
            context.quadraticCurveTo(x + width, y, x + width, y + radius);
            context.lineTo(x + width, y + height - radius);
            context.quadraticCurveTo(x + width, y + height, x + width - radius, y + height); 
            context.lineTo(x + radius, y + height);
            context.quadraticCurveTo(x, y + height, x, y + height - radius);
            context.lineTo(x, y + radius);
            context.quadraticCurveTo(x, y, x + radius, y);
            context.closePath();
        }

        /**
         * í­íƒ„ ëª¨ì–‘ì„ ê·¸ë¦¬ëŠ” í•¨ìˆ˜
         * @param {CanvasRenderingContext2D} context - ìº”ë²„ìŠ¤ 2D ì»¨í…ìŠ¤íŠ¸
         * @param {number} size - í­íƒ„ í¬ê¸° (ë°˜ì§€ë¦„ ë˜ëŠ” í­)
         */
        function drawBombShape(context, size) {
            const bombRadius = size * 0.4; // ì¹´ë“œ í¬ê¸°ì— ë¹„ë¡€
            const fuseLength = size * 0.4;
            const fuseAngle = -Math.PI / 4; // ì‹¬ì§€ ê°ë„ (ì˜¤ë¥¸ìª½ ìœ„ë¡œ)

            // í­íƒ„ ëª¸í†µ (ì›)
            context.beginPath();
            context.arc(0, bombRadius * 0.2, bombRadius, 0, Math.PI * 2, true); // ì•½ê°„ ì•„ë˜ë¡œ ë°°ì¹˜í•˜ì—¬ ì‹¬ì§€ ê³µê°„ í™•ë³´
            context.fillStyle = 'black'; // í­íƒ„ ëª¸í†µ ìƒ‰ìƒ
            context.fill();

            // ì‹¬ì§€
            context.beginPath();
            context.strokeStyle = 'darkgray'; // ì‹¬ì§€ ìƒ‰ìƒ
            context.lineWidth = 3;
            context.lineCap = 'round';
            context.moveTo(0, -bombRadius * 0.8); // ëª¸í†µ ìƒë‹¨ì—ì„œ ì‹œì‘
            context.lineTo(Math.cos(fuseAngle) * fuseLength, Math.sin(fuseAngle) * fuseLength - bombRadius * 0.8);
            context.stroke();

            // ë¶ˆê½ƒ (ì‘ì€ ì›)
            context.beginPath();
            context.arc(Math.cos(fuseAngle) * fuseLength, Math.sin(fuseAngle) * fuseLength - bombRadius * 0.8, size * 0.08, 0, Math.PI * 2, true);
            context.fillStyle = 'orange'; // ë¶ˆê½ƒ ìƒ‰ìƒ
            context.fill();
        }


        /**
         * ì¹´ë“œ ë’¤ì§‘ê¸° ì• ë‹ˆë©”ì´ì…˜ (ê³µí†µ í•¨ìˆ˜)
         * ìˆœë°œë ¥ ê²Œì„ì€ í•­ìƒ ì•ë©´ì´ë¼ ì‚¬ì‹¤ìƒ ì‚¬ìš©ë˜ì§€ ì•ŠìŒ.
         */
        function flipCardAnimation(context, card, startRotation, endRotation, callback) {
            const duration = 500;
            const startTime = performance.now();

            function animate(currentTime) {
                const elapsedTime = currentTime - startTime;
                const progress = Math.min(elapsedTime / duration, 1);
                card.displayRotation = startRotation + (endRotation - startRotation) * progress;
                // í˜„ì¬ í™œì„±í™”ëœ ê²Œì„ì˜ ìº”ë²„ìŠ¤ë§Œ ë‹¤ì‹œ ê·¸ë¦¼
                if (currentActiveGameType === 'memory') {
                    drawMemoryGame();
                } else if (currentActiveGameType === 'reaction') {
                    // drawReactionGame(); // ìˆœë°œë ¥ ê²Œì„ì—ì„œëŠ” ë³„ë„ ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ê°€ ìˆìœ¼ë¯€ë¡œ ì—¬ê¸°ì„œ ì§ì ‘ ê·¸ë¦¬ì§€ ì•ŠìŒ
                }

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    card.displayRotation = endRotation;
                    // ì—¬ê¸°ì„œë„ ì§ì ‘ drawGameì„ í˜¸ì¶œí•˜ì§€ ì•Šê³ , ë©”ì¸ ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ì— ë§¡ê¹€
                    if (callback) {
                        callback();
                    }
                }
            }
            requestAnimationFrame(animate);
        }

        /**
         * ê¸°ì–µë ¥ ê²Œì„ ìº”ë²„ìŠ¤ í´ë¦­/í„°ì¹˜ í•¸ë“¤ëŸ¬
         */
        function handleMemoryCanvasInteraction(event) {
            if (memoryLockBoard) return;

            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;

            const rect = memoryGameCanvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;

            const clickedCard = memoryCards.find(card => {
                return x >= card.x && x <= card.x + card.width &&
                       y >= card.y && y <= card.y + card.height &&
                       !card.isMatched;
            });

            if (clickedCard && !clickedCard.isFlipped && !memoryFlippedCards.includes(clickedCard)) {
                playMemoryFlipSound(); // ì¹´ë“œ ë’¤ì§‘ê¸° ì†Œë¦¬ ì¬ìƒ
                clickedCard.isFlipped = true; // ì¹´ë“œê°€ í´ë¦­ë˜ìë§ˆì isFlipped ìƒíƒœë¥¼ trueë¡œ ì„¤ì •
                memoryFlippedCards.push(clickedCard);
                memoryTotalFlips++;
                // updateMemoryInfo(); // ë¬¸êµ¬ ì‚­ì œë¡œ ë” ì´ìƒ í•„ìš” ì—†ìŒ

                flipCardAnimation(memoryCtx, clickedCard, 0, 180, () => {
                    if (memoryFlippedCards.length === 2) {
                        memoryLockBoard = true;
                        setTimeout(checkMemoryMatch, 1000);
                    }
                });
            }
        }

        function checkMemoryMatch() {
            const [card1, card2] = memoryFlippedCards;

            if (card1.value === card2.value) {
                card1.isMatched = true;
                card2.isMatched = true;
                memoryMatchedPairs++;
                // updateMemoryInfo(); // ë¬¸êµ¬ ì‚­ì œë¡œ ë” ì´ìƒ í•„ìš” ì—†ìŒ
                drawMemoryGame(); // ì§ì´ ë§ì€ ì¹´ë“œ ì‚¬ë¼ì§€ê²Œ

                if (memoryMatchedPairs === currentMemoryDifficulty.totalCards / 2) {
                    setTimeout(() => {
                        showModal('ê¸°ì–µë ¥ ì‘¥ì‘¥!', 'ì¶•í•˜í•©ë‹ˆë‹¤! ëª¨ë“  ì§ì„ ë§ì¶”ì…¨ìŠµë‹ˆë‹¤!');
                        playTaDaSound(); // ê²Œì„ ì¢…ë£Œ ì†Œë¦¬ ì¬ìƒ
                    }, 500);
                }
            } else {
                setTimeout(() => {
                    flipCardAnimation(memoryCtx, card1, 180, 0, () => {
                        card1.isFlipped = false;
                    });
                    flipCardAnimation(memoryCtx, card2, 180, 0, () => {
                        card2.isFlipped = false;
                        drawMemoryGame();
                    });
                }, 800);
            }

            memoryFlippedCards = [];
            memoryLockBoard = false;
        }

        // ë¬¸êµ¬ ì‚­ì œë¡œ ì´ í•¨ìˆ˜ëŠ” ë” ì´ìƒ í•„ìš” ì—†ìŠµë‹ˆë‹¤.
        /*
        function updateMemoryInfo() {
            // currentMemoryDifficultyê°€ ì¡´ì¬í•  ë•Œë§Œ totalCardsì— ì ‘ê·¼
            if (currentMemoryDifficulty) { 
                memoryFlippedCountSpan.textContent = memoryTotalFlips;
                memoryMatchedCountSpan.textContent = (currentMemoryDifficulty.totalCards / 2) - memoryMatchedPairs;
            }
        }
        */


        // --- ìˆœë°œë ¥ ê²Œì„ í•¨ìˆ˜ ---

        /**
         * ìˆœë°œë ¥ ê²Œì„ ì‹œì‘ í•¨ìˆ˜.
         * @param {string} difficultyKey - ì„ íƒëœ ë‚œì´ë„ í‚¤ ('easy', 'medium', 'hard')
         */
        function startReactionGame(difficultyKey) {
            playClickSound(); // ë‚œì´ë„ ì„ íƒ ë²„íŠ¼ í´ë¦­ ì†Œë¦¬
            currentActiveGameType = 'reaction';
            currentReactionDifficulty = reactionDifficulties[difficultyKey]; // í• ë‹¹ ì‹œì  ë³€ê²½: ë¨¼ì € ë‚œì´ë„ ì •ë³´ë¥¼ ì„¤ì •
            // reactionGameTitle.textContent = currentReactionDifficulty.title; // ì´ ì¤„ì€ ì´ì œ CSSë¡œ ì œëª©ì´ ìˆ¨ê²¨ì§€ë¯€ë¡œ íš¨ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.
            
            // ë‹¤ë¥¸ ê²Œì„ í™”ë©´ ë¹„í™œì„±í™” (ê¸°ì–µë ¥ ê²Œì„)
            memoryGameScreen.classList.remove('active'); 

            // ë‚œì´ë„ ì„ íƒ í›„, ë‚œì´ë„ ë²„íŠ¼ ìˆ¨ê¸°ê³  ê²Œì„ í”Œë ˆì´ ì˜ì—­ í‘œì‹œ
            reactionDifficultyButtons.style.display = 'none';
            reactionGamePlayArea.style.display = 'flex'; // flexë¡œ ì„¤ì •í•˜ì—¬ ë‚´ë¶€ ìš”ì†Œ ì •ë ¬

            // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì • (ë°˜ì‘í˜•)
            const appHeight = document.getElementById('app').clientHeight;
            const appWidth = document.getElementById('app').clientWidth;
            const screenPaddingTop = 25; // .game-screen-commonì˜ padding-top

            // game-info-commonì´ display:flex ìƒíƒœì¼ ë•Œ ë†’ì´ë¥¼ ì •í™•íˆ ì¸¡ì •
            const originalGameInfoDisplay = reactionGameInfo.style.display;
            reactionGameInfo.style.display = 'flex'; // ì¼ì‹œì ìœ¼ë¡œ flexë¡œ ì„¤ì •í•˜ì—¬ offsetHeightê°€ ì •í™•íˆ ê³„ì‚°ë˜ë„ë¡ í•¨
            const gameInfoHeight = reactionGameInfo.offsetHeight;
            reactionGameInfo.style.display = originalGameInfoDisplay; // ì›ë˜ display ìƒíƒœë¡œ ë³µì›

            const canvasMarginBottom = 25; // .game-canvas-commonì˜ margin-bottom

            // ìº”ë²„ìŠ¤ê°€ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ìµœëŒ€ ìˆ˜ì§ ê³µê°„ ê³„ì‚°
            const availableVerticalSpaceForCanvas = appHeight - screenPaddingTop - gameInfoHeight - canvasMarginBottom;
            
            const canvasRenderWidth = appWidth - (2 * CANVAS_HORIZONTAL_PADDING);
            
            const cardSpacing = 10;
            const tempCols = currentReactionDifficulty.cols; 
            const tempRows = currentReactionDifficulty.rows; 

            // ìº”ë²„ìŠ¤ ë„ˆë¹„ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì´ìƒì ì¸ ì¹´ë“œ í¬ê¸° ê³„ì‚°
            const idealCardWidth = (canvasRenderWidth - ((tempCols - 1) * cardSpacing)) / tempCols;
            const idealCardHeight = idealCardWidth; 

            // ì´ìƒì ì¸ ì¹´ë“œ í¬ê¸°ë¡œ ê·¸ë¦¬ë“œë¥¼ ë§Œë“¤ì—ˆì„ ë•Œ í•„ìš”í•œ ìº”ë²„ìŠ¤ ë†’ì´
            let idealCanvasHeight = (tempRows * idealCardHeight) + ((tempRows - 1) * cardSpacing);

            let finalCanvasWidth = canvasRenderWidth;
            let finalCanvasHeight;

            // ì´ìƒì ì¸ ìº”ë²„ìŠ¤ ë†’ì´ê°€ ì‚¬ìš© ê°€ëŠ¥í•œ ìˆ˜ì§ ê³µê°„ì„ ì´ˆê³¼í•˜ëŠ” ê²½ìš°, ë†’ì´ì— ë§ì¶° ì¹´ë“œ í¬ê¸° ì¡°ì •
            if (idealCanvasHeight > availableVerticalSpaceForCanvas) {
                finalCanvasHeight = availableVerticalSpaceForCanvas;
                const newCardHeight = (finalCanvasHeight - ((tempRows - 1) * cardSpacing)) / tempRows;
                const newCardWidth = newCardHeight; // ì¢…íš¡ë¹„ ìœ ì§€
                finalCanvasWidth = (tempCols * newCardWidth) + ((tempCols - 1) * cardSpacing);
            } else {
                finalCanvasHeight = idealCanvasHeight;
            }

            // ìº”ë²„ìŠ¤ ìµœì¢… í¬ê¸° ì„¤ì •
            reactionGameCanvas.width = finalCanvasWidth;
            reactionGameCanvas.height = finalCanvasHeight;


            reactionTargetClicksSpan.textContent = REACTION_CLICKS_NEEDED; // ëª©í‘œ í´ë¦­ ìˆ˜ ì„¤ì •
            resetReactionGameState(); // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™” (ì—¬ê¸°ì„œ ëª¨ë“  íƒ€ì´ë¨¸ ì¤‘ì§€ ë° floatingTexts ì´ˆê¸°í™”)

            showScreen('reaction-game-screen'); // ìˆœë°œë ¥ ê²Œì„ í™”ë©´ìœ¼ë¡œ ì „í™˜

            // ê²Œì„ ì‹œì‘ ì „ ì•ˆë‚´ ë° ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
            showReactionPreGameOverlay(); // ì˜¤ë²„ë ˆì´ í‘œì‹œ
            showReactionInstruction(); // ì•ˆë‚´ ì‹œì‘
        }

        function resetReactionGameState() {
            reactionScore = 0;
            reactionAttempts = 0;
            reactionTargetCard = null;
            consecutiveBombs = 0; // ì—°ì† í­íƒ„ ì¹´ìš´í„° ì´ˆê¸°í™”
            floatingTexts = []; // í”Œë¡œíŒ… í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
            reactionScoreSpan.textContent = reactionScore;
            reactionAttemptsSpan.textContent = reactionAttempts;
            drawReactionGame(); // ë¹ˆ ìº”ë²„ìŠ¤ ê·¸ë¦¬ê¸°
            stopReactionGameLoop(); // ê¸°ì¡´ ë£¨í”„ ì¤‘ì§€
            stopReactionAnimationLoop(); // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ì¤‘ì§€
            // ì˜¤ë²„ë ˆì´ ë° í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
            reactionPreGameOverlay.style.display = 'none';
            reactionInstructionText.style.display = 'flex';
            reactionCountdownText.style.display = 'none';
        }

        function showReactionPreGameOverlay() {
            // ìº”ë²„ìŠ¤ ìœ„ì— ì •í™•íˆ ê²¹ì¹˜ë„ë¡ ìœ„ì¹˜ ì¡°ì •
            // Note: Removed dynamic positioning using canvasRect to rely on CSS centering instead.
            reactionPreGameOverlay.style.display = 'flex'; // ì˜¤ë²„ë ˆì´ í‘œì‹œ
        }


        function showReactionInstruction() {
            reactionInstructionText.style.display = 'flex';
            reactionCountdownText.style.display = 'none';
            // "ë³„ ëª¨ì–‘ë§Œ ëˆŒëŸ¬ì£¼ì„¸ìš”!" ë©”ì‹œì§€ í‘œì‹œ
            reactionInstructionText.innerHTML = `
                <span class="emoji-display">â­</span>
                <span>ë³„ ëª¨ì–‘ë§Œ ëˆŒëŸ¬ì£¼ì„¸ìš”!</span>
                <span class="emoji-display">âœ¨</span>
                <span>ì‘ì€ ë³„ì€ ë” ë†’ì€ ì ìˆ˜!</span>
                <span class="emoji-display">ğŸ’£</span>
                <span>í­íƒ„ì€ ëˆ„ë¥´ë©´ ì•ˆë¼ìš”!</span>
            `;
            setTimeout(() => {
                startReactionCountdown();
            }, REACTION_INSTRUCTION_DURATION);
        }

        function startReactionCountdown() {
            reactionInstructionText.style.display = 'none';
            reactionCountdownText.style.display = 'block';
            let count = 3;

            // 3ì´ˆë¶€í„° ì†Œë¦¬ ì¬ìƒ
            reactionCountdownText.textContent = count;
            playCountdownSound("C4"); // ë”§ 

            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    reactionCountdownText.textContent = count;
                    playCountdownSound("C4"); // ë”§
                } else if (count === 0) {
                    reactionCountdownText.textContent = 'ì‹œì‘!'; // "ì‹œì‘!" í…ìŠ¤íŠ¸ëŠ” CSSì—ì„œ í¬ê¸° ì¡°ì ˆ
                    playCountdownSound("G5", "0.5"); // ë ì´!!!! (ë†’ì€ ìŒ, ê¸¸ê²Œ)
                    clearInterval(countdownInterval);
                    setTimeout(() => { // "ì‹œì‘!" ì†Œë¦¬ ì´í›„ ì§§ì€ ì§€ì—°
                        reactionPreGameOverlay.style.display = 'none'; // ì˜¤ë²„ë ˆì´ ìˆ¨ê¸°ê¸°
                        startReactionGameLoop(); // ê²Œì„ ë£¨í”„ ì‹œì‘
                        startReactionAnimationLoop(); // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ì‹œì‘
                    }, 500); 
                }
            }, 1000); // 1ì´ˆë§ˆë‹¤ ì¹´ìš´íŠ¸ë‹¤ìš´
        }


        function startReactionGameLoop() {
            stopReactionGameLoop(); // ì´ì „ì— ì‹¤í–‰ ì¤‘ì¸ ì¸í„°ë²Œì´ ìˆë‹¤ë©´ ì¤‘ì§€
            reactionGameInterval = setInterval(showRandomReactionCard, currentReactionDifficulty.interval);
        }

        function stopReactionGameLoop() {
            if (reactionGameInterval) {
                clearInterval(reactionGameInterval);
                reactionGameInterval = null;
            }
            if (reactionTargetVisibleTimer) {
                clearTimeout(reactionTargetVisibleTimer);
                reactionTargetVisibleTimer = null;
            }
        }
        
        // ìˆœë°œë ¥ ê²Œì„ì˜ ì• ë‹ˆë©”ì´ì…˜ì„ ìœ„í•œ ë³„ë„ ë£¨í”„
        function startReactionAnimationLoop() {
            stopReactionAnimationLoop(); // ê¸°ì¡´ ë£¨í”„ê°€ ìˆë‹¤ë©´ ì¤‘ì§€
            function animateReaction() {
                if (currentActiveGameType === 'reaction' && reactionGameScreen.classList.contains('active')) {
                    drawReactionGame(); // ì¹´ë“œ ë° ë°°ê²½ ê·¸ë¦¬ê¸°
                    drawFloatingTexts(reactionCtx); // í”Œë¡œíŒ… í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
                }
                reactionAnimationLoopId = requestAnimationFrame(animateReaction);
            }
            reactionAnimationLoopId = requestAnimationFrame(animateReaction);
        }

        function stopReactionAnimationLoop() {
            if (reactionAnimationLoopId) {
                cancelAnimationFrame(reactionAnimationLoopId);
                reactionAnimationLoopId = null;
            }
        }


        function showRandomReactionCard() {
            if (reactionScore >= REACTION_CLICKS_NEEDED) { // ëª©í‘œ ë‹¬ì„± ì‹œ ì¤‘ì§€
                stopReactionGameLoop();
                return;
            }

            // ì´ì „ íƒ€ê²Ÿì´ ë‚¨ì•„ìˆë‹¤ë©´ ì§€ìš°ê¸° (ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ê°€ ìˆìœ¼ë¯€ë¡œ ë°”ë¡œ ê·¸ë¦¬ì§€ ì•ŠìŒ)
            reactionTargetCard = null;
            if (reactionTargetVisibleTimer) {
                clearTimeout(reactionTargetVisibleTimer);
                reactionTargetVisibleTimer = null;
            }

            reactionAttempts++; // ì‹œë„ íšŸìˆ˜ ì¦ê°€
            reactionAttemptsSpan.textContent = reactionAttempts;

            const cardSpacing = 10;
            // í˜„ì¬ ë‚œì´ë„ì˜ ì„¤ì •ëœ ì»¬ëŸ¼ ë° ë¡œìš°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•œ ê¸°ë³¸ ì¹´ë“œ ë„ˆë¹„/ë†’ì´ ê³„ì‚°
            // ìº”ë²„ìŠ¤ê°€ ì´ë¯¸ ìµœì¢… í¬ê¸°ë¡œ ì¡°ì •ë˜ì—ˆìœ¼ë¯€ë¡œ, ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì¹´ë“œ í¬ê¸°ë¥¼ ê³„ì‚°
            const baseCardWidth = (reactionGameCanvas.width - ((currentReactionDifficulty.cols - 1) * cardSpacing)) / currentReactionDifficulty.cols;
            const baseCardHeight = baseCardWidth; // ì •ì‚¬ê°í˜• ì¹´ë“œ

            let currentCardWidth = baseCardWidth;
            let currentCardHeight = baseCardHeight;
            let currentCardDuration = currentReactionDifficulty.duration;

            // ì¹´ë“œ íƒ€ì… ê²°ì •
            let cardType;
            const randomValue = Math.random();

            // ì—°ì† í­íƒ„ ì œí•œ ë¡œì§
            if (consecutiveBombs >= MAX_CONSECUTIVE_BOMBS || randomValue < 0.65) { // 65% ì¼ë°˜ ë³„
                cardType = 'star';
                consecutiveBombs = 0; // ë³„ì´ ë‚˜ì˜¤ë©´ ì—°ì† í­íƒ„ ì¹´ìš´í„° ë¦¬ì…‹
            } else if (randomValue < 0.70) { // 5% ì‘ì€ ë³„ (0.65 ~ 0.70)
                cardType = 'superStar';
                consecutiveBombs = 0;
                // ì‘ì€ ë³„ì€ í¬ê¸°ì™€ ì§€ì† ì‹œê°„ì„ ì¡°ì ˆ
                currentCardWidth *= 0.7;
                currentCardHeight *= 0.7;
                currentCardDuration *= 0.7;
            } else { // ë‚˜ë¨¸ì§€ 30% í­íƒ„ (0.70 ~ 1.0)
                cardType = 'bomb';
                consecutiveBombs++; // í­íƒ„ì´ ë‚˜ì˜¤ë©´ ì—°ì† í­íƒ„ ì¹´ìš´í„° ì¦ê°€
            }

            // ìº”ë²„ìŠ¤ ë‚´ì—ì„œ ì¹´ë“œê°€ ì™„ì „íˆ ë“¤ì–´ê°ˆ ìˆ˜ ìˆëŠ” ìµœëŒ€ X, Y ì‹œì‘ ìœ„ì¹˜ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
            const maxCardStartX = Math.max(0, reactionGameCanvas.width - currentCardWidth);
            const maxCardStartY = Math.max(0, reactionGameCanvas.height - currentCardHeight);

            // ì´ì œ ì´ ìµœëŒ€ ì‹œì‘ ìœ„ì¹˜ ë‚´ì—ì„œ ë¬´ì‘ìœ„ ì¢Œí‘œë¥¼ ì„ íƒí•©ë‹ˆë‹¤.
            const x = Math.random() * maxCardStartX;
            const y = Math.random() * maxCardStartY;

            reactionTargetCard = {
                type: cardType,
                value: cardType === 'star' ? STAR_EMOJI : (cardType === 'superStar' ? SUPER_STAR_EMOJI : BOMB_EMOJI),
                x: x, // ë¬´ì‘ìœ„ X ì¢Œí‘œ
                y: y, // ë¬´ì‘ìœ„ Y ì¢Œí‘œ
                width: currentCardWidth,
                height: currentCardHeight,
                isFlipped: true, // í•­ìƒ ì•ë©´ìœ¼ë¡œ í‘œì‹œ
                isMatched: false,
                displayRotation: 180 // ì•ë©´ ë³´ì´ë„ë¡
            };

            // ì¼ì • ì‹œê°„ í›„ íƒ€ê²Ÿ ì¹´ë“œ ì‚¬ë¼ì§€ê²Œ
            reactionTargetVisibleTimer = setTimeout(() => {
                reactionTargetCard = null;
            }, currentCardDuration);
        }

        /**
         * ìˆœë°œë ¥ ê²Œì„ ë³´ë“œë¥¼ ê·¸ë¦½ë‹ˆë‹¤.
         */
        function drawReactionGame() {
            reactionCtx.clearRect(0, 0, reactionGameCanvas.width, reactionGameCanvas.height);

            // íƒ€ê²Ÿ ì¹´ë“œê°€ ìˆë‹¤ë©´ ê·¸ë¦¬ê¸°
            if (reactionTargetCard) {
                let cardFrontColor, cardTextColor;
                if (reactionTargetCard.type === 'star') {
                    cardFrontColor = TARGET_CARD_COLOR_STAR;
                    cardTextColor = TARGET_TEXT_COLOR_STAR;
                } else if (reactionTargetCard.type === 'superStar') {
                    cardFrontColor = TARGET_CARD_COLOR_SUPER_STAR;
                    cardTextColor = TARGET_TEXT_COLOR_SUPER_STAR;
                } else { // bomb
                    cardFrontColor = TARGET_CARD_COLOR_BOMB;
                    cardTextColor = TARGET_TEXT_COLOR_BOMB;
                }
                drawCard(reactionCtx, reactionTargetCard, CARD_COLOR_BACK, cardFrontColor, cardTextColor, CARD_BORDER_COLOR);
            }
        }

        /**
         * í´ë¦­ ì‹œ í‘œì‹œë˜ëŠ” +1/-1 í…ìŠ¤íŠ¸ë¥¼ ê·¸ë¦¬ëŠ” í•¨ìˆ˜
         * @param {CanvasRenderingContext2D} context - ìº”ë²„ìŠ¤ 2D ì»¨í…ìŠ¤íŠ¸
         */
        function drawFloatingTexts(context) {
            const currentTime = performance.now();
            floatingTexts = floatingTexts.filter(textObj => {
                const elapsedTime = currentTime - textObj.startTime;
                const animationDuration = 800; // í…ìŠ¤íŠ¸ê°€ ë‚˜íƒ€ë‚˜ê³  ì‚¬ë¼ì§€ëŠ” ì´ ì‹œê°„ (ms)
                const moveDistance = 50; // í…ìŠ¤íŠ¸ê°€ ìœ„ë¡œ ì›€ì§ì´ëŠ” ê±°ë¦¬ (px)

                if (elapsedTime > animationDuration) return false; // ì• ë‹ˆë©”ì´ì…˜ì´ ëë‚˜ë©´ ë°°ì—´ì—ì„œ ì œê±°

                const progress = elapsedTime / animationDuration;
                textObj.alpha = Math.max(0, 1 - progress); // ì‹œê°„ì´ ì§€ë‚¨ì— ë”°ë¼ íˆ¬ëª…ë„ ê°ì†Œ
                textObj.offsetY = -progress * moveDistance; // ì‹œê°„ì´ ì§€ë‚¨ì— ë”°ë¼ ìœ„ë¡œ ì´ë™

                context.save();
                context.globalAlpha = textObj.alpha;
                context.fillStyle = textObj.color;
                // í°íŠ¸ í¬ê¸°ë¥¼ ì‹œê°„ ê²½ê³¼ì— ë”°ë¼ ì•½ê°„ ì¤„ì–´ë“¤ê²Œ í•˜ì—¬ ì‹œê°ì  íš¨ê³¼ ì¶”ê°€
                context.font = `bold ${30 * (1 - progress * 0.5)}px Inter`; 
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                // ì›ë˜ ìœ„ì¹˜ì—ì„œ offsetYë§Œí¼ ìœ„ë¡œ ì´ë™í•˜ì—¬ ê·¸ë¦¬ê¸°
                context.fillText(textObj.text, textObj.x, textObj.y + textObj.offsetY);
                context.restore();
                return true;;
            });
        }


        /**
         * ìˆœë°œë ¥ ê²Œì„ ìº”ë²„ìŠ¤ í´ë¦­/í„°ì¹˜ í•¸ë“¤ëŸ¬
         */
        function handleReactionCanvasInteraction(event) {
            // ê²Œì„ì´ ì§„í–‰ ì¤‘ì¸ ìƒíƒœì—ì„œë§Œ í´ë¦­ ì²˜ë¦¬ (ì˜¤ë²„ë ˆì´ê°€ í™œì„±í™”ëœ ìƒíƒœì—ì„œëŠ” í´ë¦­ ë¬´ì‹œ)
            if (!reactionGameInterval || reactionPreGameOverlay.style.display !== 'none') return;

            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;

            const rect = reactionGameCanvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;

            // í´ë¦­ íŒì • ì˜ì—­ì„ í™•ì¥í•˜ì—¬ ê²€ì‚¬
            if (reactionTargetCard &&
                x >= reactionTargetCard.x - CLICK_PADDING_PIXELS &&
                x <= reactionTargetCard.x + reactionTargetCard.width + CLICK_PADDING_PIXELS &&
                y >= reactionTargetCard.y - CLICK_PADDING_PIXELS &&
                y <= reactionTargetCard.y + reactionTargetCard.height + CLICK_PADDING_PIXELS) {
                
                // í´ë¦­ëœ ì¹´ë“œì˜ ì¤‘ì•™ ì¢Œí‘œ ê³„ì‚° (ì ìˆ˜ í…ìŠ¤íŠ¸ í‘œì‹œìš©)
                const textX = reactionTargetCard.x + reactionTargetCard.width / 2;
                const textY = reactionTargetCard.y + reactionTargetCard.height / 2;

                // íƒ€ê²Ÿ ì¹´ë“œë¥¼ ë§ì¶¤
                if (reactionTargetCard.type === 'star') {
                    reactionScore++;
                    floatingTexts.push({ text: '+1ì ', x: textX, y: textY, color: '#4CAF50', startTime: performance.now() }); /* ì´ˆë¡ìƒ‰ */
                    playStarClickSound(); // ë³„ í´ë¦­ ì†Œë¦¬ ì¬ìƒ
                } else if (reactionTargetCard.type === 'superStar') { // ì‘ì€ ë³„
                    reactionScore += 3;
                    floatingTexts.push({ text: '+3ì ', x: textX, y: textY, color: '#FFD700', startTime: performance.now() }); /* í™©ê¸ˆìƒ‰ */
                    playStarClickSound(); // ë³„ í´ë¦­ ì†Œë¦¬ ì¬ìƒ (ë™ì¼ ì‚¬ìš´ë“œ)
                } else if (reactionTargetCard.type === 'bomb') {
                    reactionScore = Math.max(0, reactionScore - 1); // ì ìˆ˜ 0 ë¯¸ë§Œìœ¼ë¡œ ë‚´ë ¤ê°€ì§€ ì•Šë„ë¡
                    floatingTexts.push({ text: '-1ì ', x: textX, y: textY, color: '#F44336', startTime: performance.now() }); /* ë¹¨ê°„ìƒ‰ */
                    playBombClickSound(); // í­íƒ„ í´ë¦­ ì†Œë¦¬ ì¬ìƒ
                }
                reactionScoreSpan.textContent = reactionScore;
                
                // íƒ€ê²Ÿ ì¹´ë“œ ë°”ë¡œ ì‚¬ë¼ì§€ê²Œ í•˜ê³  ë‹¤ìŒ ì¹´ë“œ ì¤€ë¹„
                reactionTargetCard = null;
                // drawReactionGame(); // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ê°€ ì§€ìš¸ ê²ƒì´ë¯€ë¡œ ì—¬ê¸°ì„œ ì§ì ‘ í˜¸ì¶œí•˜ì§€ ì•ŠìŒ
                if (reactionTargetVisibleTimer) {
                    clearTimeout(reactionTargetVisibleTimer);
                    reactionTargetVisibleTimer = null;
                }

                if (reactionScore >= REACTION_CLICKS_NEEDED) {
                    stopReactionGameLoop();
                    stopReactionAnimationLoop(); // ê²Œì„ ì¢…ë£Œ ì‹œ ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ë„ ì¤‘ì§€
                    setTimeout(() => {
                        showModal('ìˆœë°œë ¥ ë²ˆì©!', 'ì¶•í•˜í•©ë‹ˆë‹¤! ëª©í‘œë¥¼ ë‹¬ì„±í–ˆìŠµë‹ˆë‹¤!');
                        playTaDaSound(); // ê²Œì„ ì¢…ë£Œ ì†Œë¦¬ ì¬ìƒ
                    }, 100);
                }
            }
            // íƒ€ê²Ÿì´ ì—†ê±°ë‚˜ ì—‰ëš±í•œ ê³³ì„ í´ë¦­í•œ ê²½ìš° ë¬´ì‹œ
        }


        // --- êµ¬êµ¬ë‹¨ ê²Œì„ í•¨ìˆ˜ ---

        /**
         * êµ¬êµ¬ë‹¨ ê²Œì„ ì‹œì‘ í•¨ìˆ˜.
         */
        function startGugudanGame() {
            playClickSound(); // ê²Œì„ ì‹œì‘ ë²„íŠ¼ í´ë¦­ ì†Œë¦¬
            currentActiveGameType = 'gugudan';
            
            showScreen('gugudan-game-screen');
            currentGugudanQuestionIndex = 0;
            gugudanScore = 0;
            generateGugudanQuestions();
            displayGugudanQuestion();
        }

        /**
         * êµ¬êµ¬ë‹¨ ë¬¸ì œë“¤ì„ ìƒì„±í•©ë‹ˆë‹¤.
         */
        function generateGugudanQuestions() {
            gugudanQuestions = [];
            for (let i = 0; i < TOTAL_GUGUDAN_QUESTIONS; i++) {
                const num1 = Math.floor(Math.random() * 8) + 2; // 2ì—ì„œ 9ê¹Œì§€
                const num2 = Math.floor(Math.random() * 8) + 2; // 2ì—ì„œ 9ê¹Œì§€
                const correctAnswer = num1 * num2;
                
                let options = new Set();
                options.add(correctAnswer);

                // ì˜¤ë‹µ ìƒì„± (ì •ë‹µ ì£¼ë³€ ê°’, ë˜ëŠ” ë‹¤ë¥¸ ì¡°í•©)
                while (options.size < 4) {
                    let incorrectAnswer;
                    const randomType = Math.random();
                    if (randomType < 0.33) { // num1 ë³€ê²½
                        incorrectAnswer = (num1 + (Math.random() < 0.5 ? 1 : -1)) * num2;
                    } else if (randomType < 0.66) { // num2 ë³€ê²½
                        incorrectAnswer = num1 * (num2 + (Math.random() < 0.5 ? 1 : -1));
                    } else { // ëœë¤ ê°’
                        incorrectAnswer = Math.floor(Math.random() * 81) + 4; // 4ì—ì„œ 84 (2*2~9*9 ë²”ìœ„ ê³ ë ¤)
                    }
                    // ë„ˆë¬´ ì‰½ê±°ë‚˜ ë„ˆë¬´ ì–´ë ¤ìš´ ì˜¤ë‹µ ë°©ì§€ (ì˜ˆ: 0ì´í•˜, 100ì´ìƒ, í˜„ì¬ ê°’ê³¼ ë„ˆë¬´ ì°¨ì´ë‚˜ëŠ” ê²½ìš° ì œì™¸)
                    if (incorrectAnswer > 0 && incorrectAnswer <= 81 && Math.abs(incorrectAnswer - correctAnswer) > 1 && incorrectAnswer !== correctAnswer) {
                        options.add(incorrectAnswer);
                    }
                }
                
                const shuffledOptions = Array.from(options).sort(() => Math.random() - 0.5);

                gugudanQuestions.push({
                    problem: `${num1} X ${num2} = ?`,
                    correctAnswer: correctAnswer,
                    options: shuffledOptions
                });
            }
        }

        /**
         * í˜„ì¬ êµ¬êµ¬ë‹¨ ë¬¸ì œë¥¼ í™”ë©´ì— í‘œì‹œí•©ë‹ˆë‹¤.
         */
        function displayGugudanQuestion() {
            if (currentGugudanQuestionIndex >= TOTAL_GUGUDAN_QUESTIONS) {
                showGugudanResults();
                return;
            }

            const currentQuestion = gugudanQuestions[currentGugudanQuestionIndex];
            gugudanQuestionNumberDisplay.textContent = `ë¬¸ì œ ${currentGugudanQuestionIndex + 1}/${TOTAL_GUGUDAN_QUESTIONS}`;
            gugudanProblemDisplay.textContent = currentQuestion.problem;

            gugudanOptionButtons.forEach((button, index) => {
                button.textContent = currentQuestion.options[index];
                button.disabled = false; // ë²„íŠ¼ ë‹¤ì‹œ í™œì„±í™”
                button.onclick = (event) => handleGugudanAnswer(parseInt(button.textContent), event.target); // í´ë¦­ëœ ë²„íŠ¼ ì „ë‹¬
            });
            // ë¬¸ì œ í‘œì‹œë  ë•Œ ê¸°ì¡´ í”¼ë“œë°± í…ìŠ¤íŠ¸ ì œê±° (ìˆë‹¤ë©´)
            document.querySelectorAll('.gugudan-feedback-text').forEach(el => el.remove());
        }

        /**
         * êµ¬êµ¬ë‹¨ ë¬¸ì œì— ëŒ€í•œ ì‚¬ìš©ìì˜ ë‹µë³€ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
         * @param {number} selectedAnswer - ì‚¬ìš©ìê°€ ì„ íƒí•œ ë‹µ
         * @param {HTMLElement} clickedButton - ì‚¬ìš©ìê°€ í´ë¦­í•œ ë²„íŠ¼ ìš”ì†Œ
         */
        function handleGugudanAnswer(selectedAnswer, clickedButton) {
            playClickSound(); // ë‹µë³€ ë²„íŠ¼ í´ë¦­ ì†Œë¦¬
            const currentQuestion = gugudanQuestions[currentGugudanQuestionIndex];

            // ëª¨ë“  ë‹µë³€ ë²„íŠ¼ ë¹„í™œì„±í™”
            gugudanOptionButtons.forEach(button => button.disabled = true);

            const feedbackTextElement = document.createElement('div');
            feedbackTextElement.classList.add('gugudan-feedback-text');

            if (selectedAnswer === currentQuestion.correctAnswer) {
                gugudanScore++;
                playStarClickSound(); // ì •ë‹µ ì‚¬ìš´ë“œ
                feedbackTextElement.textContent = 'ì •ë‹µ!!';
                feedbackTextElement.style.color = '#4CAF50'; // ì´ˆë¡ìƒ‰
            } else {
                playBombClickSound(); // ì˜¤ë‹µ ì‚¬ìš´ë“œ
                feedbackTextElement.textContent = 'ì˜¤ë‹µ!';
                feedbackTextElement.style.color = '#F44336'; // ë¹¨ê°„ìƒ‰
            }

            // í´ë¦­ëœ ë²„íŠ¼ ìœ„ì¹˜ì— í”¼ë“œë°± í…ìŠ¤íŠ¸ ìœ„ì¹˜ ì„¤ì •
            const buttonRect = clickedButton.getBoundingClientRect();
            const appRect = document.getElementById('app').getBoundingClientRect();

            // app ìš”ì†Œì˜ ì™¼ìª½ ìƒë‹¨ ëª¨ì„œë¦¬ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë²„íŠ¼ì˜ ì¤‘ì•™ ì¢Œí‘œ ê³„ì‚°
            feedbackTextElement.style.left = `${buttonRect.left - appRect.left + buttonRect.width / 2}px`;
            feedbackTextElement.style.top = `${buttonRect.top - appRect.top + buttonRect.height / 2}px`;
            
            feedbackTextElement.style.position = 'absolute'; // app ê¸°ì¤€ìœ¼ë¡œ absolute
            feedbackTextElement.style.transform = 'translate(-50%, -50%)'; // ì¤‘ì•™ ì •ë ¬
            document.getElementById('app').appendChild(feedbackTextElement); // appì— ì¶”ê°€í•˜ì—¬ ìœ„ì¹˜ ì œì–´

            // ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
            setTimeout(() => {
                feedbackTextElement.style.opacity = 1;
                feedbackTextElement.style.transform = 'translate(-50%, -80%)'; // ì‚´ì§ ìœ„ë¡œ ì´ë™í•˜ë©´ì„œ ë‚˜íƒ€ë‚¨
            }, 50); // ì§§ì€ ì§€ì—° í›„ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘

            setTimeout(() => {
                // í”¼ë“œë°± í…ìŠ¤íŠ¸ ì‚¬ë¼ì§€ê²Œ
                feedbackTextElement.style.opacity = 0;
                feedbackTextElement.style.transform = 'translate(-50%, -100%)'; // ë” ìœ„ë¡œ ì‚¬ë¼ì§
                
                // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ìš”ì†Œ ì œê±°
                feedbackTextElement.addEventListener('transitionend', () => {
                    feedbackTextElement.remove();
                }, { once: true }); // í•œ ë²ˆë§Œ ì‹¤í–‰ë˜ë„ë¡

                currentGugudanQuestionIndex++;
                displayGugudanQuestion(); // ë‹¤ìŒ ë¬¸ì œ í‘œì‹œ (ì´ í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ ë²„íŠ¼ ë‹¤ì‹œ í™œì„±í™”)
            }, 1000); // 1ì´ˆ í›„ ë‹¤ìŒ ë¬¸ì œë¡œ ë„˜ì–´ê° (í”¼ë“œë°± í™•ì¸ ì‹œê°„)
        }

        /**
         * êµ¬êµ¬ë‹¨ ê²Œì„ ê²°ê³¼ë¥¼ ëª¨ë‹¬ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
         */
        function showGugudanResults() {
            showModal('êµ¬êµ¬ë‹¨ ê²Œì„ ì¢…ë£Œ!', `ì´ ${TOTAL_GUGUDAN_QUESTIONS}ë¬¸ì œ ì¤‘ ${gugudanScore}ê°œ ë§ì·„ìŠµë‹ˆë‹¤!`);
            playTaDaSound(); // ê²Œì„ ì¢…ë£Œ ì‚¬ìš´ë“œ
        }


        // --- ê³µí†µ ëª¨ë‹¬ í•¨ìˆ˜ ---

        /**
         * ì‚¬ìš©ìì—ê²Œ ë©”ì‹œì§€ë¥¼ ë³´ì—¬ì£¼ëŠ” ì»¤ìŠ¤í…€ ëª¨ë‹¬
         * @param {string} title - ëª¨ë‹¬ ì œëª©
         * @param {string} message - í‘œì‹œí•  ë©”ì‹œì§€
         */
        function showModal(title, message) {
            const modal = document.createElement('div');
            modal.className = 'custom-modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <h3>${title}</h3>
                    <p>${message}</p>
                    <button class="modal-close-button">í™•ì¸</button>
                </div>
            `;
            document.body.appendChild(modal);

            const closeButton = modal.querySelector('.modal-close-button');
            closeButton.onclick = () => {
                document.body.removeChild(modal);
                // ëª¨ë‹¬ ë‹«ìœ¼ë©´ í™ˆ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°€ê¸°
                showScreen('home-screen');
                // ê²Œì„ ë£¨í”„ ì¤‘ì§€ (í˜¹ì‹œ ëª¨ë¥¼ ìƒí™© ëŒ€ë¹„)
                stopReactionGameLoop();
                stopReactionAnimationLoop(); // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ì¤‘ì§€
                // ìˆœë°œë ¥ ê²Œì„ í™”ë©´ ì´ˆê¸°í™”
                reactionDifficultyButtons.style.display = 'flex'; // ë‚œì´ë„ ë²„íŠ¼ ë‹¤ì‹œ ë³´ì´ê²Œ
                reactionGamePlayArea.style.display = 'none'; // í”Œë ˆì´ ì˜ì—­ ìˆ¨ê¸°ê¸°
                reactionGameCanvas.width = 0; // ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
                reactionGameCanvas.height = 0;
                reactionCtx.clearRect(0, 0, 0, 0); // ìº”ë²„ìŠ¤ ë‚´ìš© ì´ˆê¸°í™”
                floatingTexts = []; // í”Œë¡œíŒ… í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
            };
        }

        // --- ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ ---

        // í™ˆ í™”ë©´: ê²Œì„ ì„ íƒ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
        gameSelectionButtons.addEventListener('click', (event) => {
            if (event.target.tagName === 'BUTTON') {
                if (!initializedAudio) { // ì²« ë²„íŠ¼ í´ë¦­ ì‹œ Tone.js ì´ˆê¸°í™”
                    Tone.start();
                    initializedAudio = true;
                }
                playClickSound(); // ê²Œì„ ì„ íƒ ë²„íŠ¼ í´ë¦­ ì†Œë¦¬

                const gameType = event.target.dataset.gameType;
                if (gameType === 'memory') {
                    showScreen('memory-game-screen');
                    // ê¸°ì–µë ¥ ê²Œì„ ì„ íƒ ì‹œ ë‚œì´ë„ ë²„íŠ¼ì€ ë³´ì´ê²Œ, ìº”ë²„ìŠ¤ìŠ¤ëŠ” ìˆ¨ê¸°ê²Œ
                    memoryDifficultyButtons.style.display = 'flex'; // ë‚œì´ë„ ë²„íŠ¼ ë³´ì´ê¸°
                    memoryGameCanvas.style.display = 'none'; // ìº”ë²„ìŠ¤ ìˆ¨ê¸°ê¸°
                    memoryGameInfo.style.display = 'none'; // ë‚œì´ë„ ì„ íƒ í™”ë©´ì—ì„œ ì •ë³´ ìˆ¨ê¸°ê¸°
                    memoryGameCanvas.width = 0; // ìº”ë²„ìŠ¤ í¬ê¸° ì´ˆê¸°í™”
                    memoryGameCanvas.height = 0;
                    memoryCtx.clearRect(0, 0, 0, 0); // ìº”ë²„ìŠ¤ ë‚´ìš© ì´ˆê¸°í™”
                    currentMemoryDifficulty = null; // ë‚œì´ë„ ì„ íƒ ì „ ì´ˆê¸°í™”
                } else if (gameType === 'reaction') {
                    showScreen('reaction-game-screen');
                    // ìˆœë°œë ¥ ê²Œì„ ì„ íƒ ì‹œ, ë‚œì´ë„ ë²„íŠ¼ì€ ë³´ì´ê³  í”Œë ˆì´ ì˜ì—­ì€ ìˆ¨ê¹€
                    reactionDifficultyButtons.style.display = 'flex';
                    reactionGamePlayArea.style.display = 'none';
                    reactionGameTitle.textContent = 'ìˆœë°œë ¥ ë²ˆì© ì¹´ë“œ í´ë¦­'; // ì´ˆê¸° ì œëª© ì„¤ì • (CSSë¡œ ìˆ¨ê²¨ì§)
                    reactionGameCanvas.width = 0; // ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
                    reactionGameCanvas.height = 0;
                    reactionCtx.clearRect(0, 0, 0, 0); // ìº”ë²„ìŠ¤ ë‚´ìš© ì´ˆê¸°í™”
                    floatingTexts = []; // ìƒˆë¡œìš´ ê²Œì„ ì‹œì‘ ì‹œ í”Œë¡œíŒ… í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
                } else if (gameType === 'gugudan') { // êµ¬êµ¬ë‹¨ ê²Œì„ ì„ íƒ ì‹œ
                    startGugudanGame();
                }
            }
        });

        // ê¸°ì–µë ¥ ê²Œì„ ë‚œì´ë„ ì„ íƒ
        memoryDifficultyButtons.addEventListener('click', (event) => {
            if (event.target.tagName === 'BUTTON') {
                const difficulty = event.target.dataset.difficulty;
                startMemoryGame(difficulty);
            }
        });

        // ìˆœë°œë ¥ ê²Œì„ ë‚œì´ë„ ì„ íƒ
        reactionDifficultyButtons.addEventListener('click', (event) => {
            if (event.target.tagName === 'BUTTON') {
                const difficulty = event.target.dataset.difficulty;
                startReactionGame(difficulty); // ê²Œì„ ì‹œì‘ í•¨ìˆ˜ í˜¸ì¶œ
            }
        });


        // ê¸°ì–µë ¥ ê²Œì„ ìº”ë²„ìŠ¤ í´ë¦­ ë° í„°ì¹˜ ì´ë²¤íŠ¸
        memoryGameCanvas.addEventListener('click', handleMemoryCanvasInteraction);
        memoryGameCanvas.addEventListener('touchend', handleMemoryCanvasInteraction, { passive: false });

        // ìˆœë°œë ¥ ê²Œì„ ìº”ë²„ìŠ¤ í´ë¦­ ë° í„°ì¹˜ ì´ë²¤íŠ¸
        reactionGameCanvas.addEventListener('click', handleReactionCanvasInteraction);
        reactionGameCanvas.addEventListener('touchend', handleReactionCanvasInteraction, { passive: false });

        // ê¸°ì–µë ¥ ê²Œì„: ë‹¤ì‹œ ì‹œì‘ ë²„íŠ¼
        memoryRestartButton.addEventListener('click', () => {
            playClickSound(); // ë‹¤ì‹œ ì‹œì‘ ë²„íŠ¼ í´ë¦­ ì†Œë¦¬
            if (currentMemoryDifficulty) {
                startMemoryGame(Object.keys(memoryDifficulties).find(key => memoryDifficulties[key] === currentMemoryDifficulty));
            }
        });

        // ê¸°ì–µë ¥ ê²Œì„: í™ˆìœ¼ë¡œ ë²„íŠ¼
        memoryHomeButton.addEventListener('click', () => {
            playClickSound(); // í™ˆìœ¼ë¡œ ë²„íŠ¼ í´ë¦­ ì†Œë¦¬
            showScreen('home-screen');
            // ê¸°ì–µë ¥ ê²Œì„ í™”ë©´ ìƒíƒœ ì´ˆê¸°í™”
            memoryDifficultyButtons.style.display = 'flex'; // ë‚œì´ë„ ë²„íŠ¼ ë³´ì´ê¸°
            memoryGameCanvas.style.display = 'none'; // ìº”ë²„ìŠ¤ ìˆ¨ê¸°ê¸°
            memoryGameInfo.style.display = 'none'; // í™ˆìœ¼ë¡œ ê°ˆ ë•Œ ì •ë³´ ìˆ¨ê¸°ê¸°
            memoryGameCanvas.width = 0; // ìº”ë²„ìŠ¤ í¬ê¸° ì´ˆê¸°í™”
            memoryGameCanvas.height = 0;
            memoryCtx.clearRect(0, 0, 0, 0); // ìº”ë²„ìŠ¤ ë‚´ìš© ì´ˆê¸°í™”
            currentMemoryDifficulty = null; // í™ˆìœ¼ë¡œ ê°ˆ ë•Œ ë‚œì´ë„ ì„¤ì • ì´ˆê¸°í™”
        });

        // ìˆœë°œë ¥ ê²Œì„: ë‹¤ì‹œ ì‹œì‘ ë²„íŠ¼
        reactionRestartButton.addEventListener('click', () => {
            playClickSound(); // ë‹¤ì‹œ ì‹œì‘ ë²„íŠ¼ í´ë¦­ ì†Œë¦¬
            if (currentReactionDifficulty) {
                // ê²Œì„ ë£¨í”„ ì¤‘ì§€ í›„ ë‹¤ì‹œ ì‹œì‘
                stopReactionGameLoop(); 
                stopReactionAnimationLoop(); // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ë„ ì¤‘ì§€
                startReactionGame(Object.keys(reactionDifficulties).find(key => reactionDifficulties[key] === currentReactionDifficulty));
            }
        });

        // ìˆœë°œë ¥ ê²Œì„: í™ˆìœ¼ë¡œ ë²„íŠ¼
        reactionHomeButton.addEventListener('click', () => {
            playClickSound(); // í™ˆìœ¼ë¡œ ë²„íŠ¼ í´ë¦­ ì†Œë¦¬
            showScreen('home-screen');
            stopReactionGameLoop(); // í™ˆìœ¼ë¡œ ê°ˆ ë•Œ ë£¨í”„ ì¤‘ì§€
            stopReactionAnimationLoop(); // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ì¤‘ì§€
            // ìˆœë°œë ¥ ê²Œì„ í™”ë©´ ì´ˆê¸°í™”
            reactionDifficultyButtons.style.display = 'flex'; // ë‚œì´ë„ ë²„íŠ¼ ë‹¤ì‹œ ë³´ì´ê²Œ
            reactionGamePlayArea.style.display = 'none'; // í”Œë ˆì´ ì˜ì—­ ìˆ¨ê¸°ê¸°
            reactionGameCanvas.width = 0; // ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
            reactionGameCanvas.height = 0;
            reactionCtx.clearRect(0, 0, 0, 0); // ìº”ë²„ìŠ¤ ë‚´ìš© ì´ˆê¸°í™”
            floatingTexts = []; // í”Œë¡œíŒ… í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
        });

        // êµ¬êµ¬ë‹¨ ê²Œì„: ë‹¤ì‹œ ì‹œì‘ ë²„íŠ¼
        gugudanRestartButton.addEventListener('click', () => {
            playClickSound(); // ë‹¤ì‹œ ì‹œì‘ ë²„íŠ¼ í´ë¦­ ì†Œë¦¬
            startGugudanGame();
        });

        // êµ¬êµ¬ë‹¨ ê²Œì„: í™ˆìœ¼ë¡œ ë²„íŠ¼
        gugudanHomeButton.addEventListener('click', () => {
            playClickSound(); // í™ˆìœ¼ë¡œ ë²„íŠ¼ í´ë¦­ ì†Œë¦¬
            showScreen('home-screen');
        });


        // ì°½ í¬ê¸° ë³€ê²½ ì‹œ ìº”ë²„ìŠ¤ ë° ê²Œì„ ì¬ì¡°ì •
        window.addEventListener('resize', () => {
            if (currentActiveGameType === 'memory' && memoryGameScreen.classList.contains('active')) {
                if (currentMemoryDifficulty) { // ê²Œì„ì´ í™œì„±í™”ëœ ìƒíƒœ, ìº”ë²„ìŠ¤ í¬ê¸° ì¬ì¡°ì • ë° ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                    // Re-calculate canvas size on resize using the same logic as startMemoryGame
                    const appHeight = document.getElementById('app').clientHeight;
                    const appWidth = document.getElementById('app').clientWidth;
                    const screenPaddingTop = 25; 

                    const originalGameInfoDisplay = memoryGameInfo.style.display;
                    memoryGameInfo.style.display = 'flex'; 
                    const gameInfoHeight = memoryGameInfo.offsetHeight;
                    memoryGameInfo.style.display = originalGameInfoDisplay; 

                    const canvasMarginBottom = 25; 

                    let availableVerticalSpaceForCanvas = appHeight - screenPaddingTop - gameInfoHeight - canvasMarginBottom;

                    const currentDifficultyKey = Object.keys(memoryDifficulties).find(key => memoryDifficulties[key] === currentMemoryDifficulty);
                    if (currentDifficultyKey === 'easy' || currentDifficultyKey === 'hard') {
                        availableVerticalSpaceForCanvas -= BUTTON_VISIBILITY_REDUCTION;
                    }

                    const canvasRenderWidth = appWidth - (2 * CANVAS_HORIZONTAL_PADDING);
                    
                    const cardSpacing = 10;
                    const tempCols = currentMemoryDifficulty.cols;
                    const tempRows = currentMemoryDifficulty.rows;

                    const idealCardWidth = (canvasRenderWidth - ((tempCols - 1) * cardSpacing)) / tempCols;
                    const idealCardHeight = idealCardWidth; 

                    let idealCanvasHeight = (tempRows * idealCardHeight) + ((tempRows - 1) * cardSpacing);

                    let finalCanvasWidth = canvasRenderWidth;
                    let finalCanvasHeight;

                    if (idealCanvasHeight > availableVerticalSpaceForCanvas) {
                        finalCanvasHeight = availableVerticalSpaceForCanvas;
                        const newCardHeight = (finalCanvasHeight - ((tempRows - 1) * cardSpacing)) / tempRows;
                        const newCardWidth = newCardHeight; 
                        finalCanvasWidth = (tempCols * newCardWidth) + ((tempCols - 1) * cardSpacing);
                    } else {
                        finalCanvasHeight = idealCanvasHeight;
                    }

                    memoryGameCanvas.width = finalCanvasWidth;
                    memoryGameCanvas.height = finalCanvasHeight;
                    
                    drawMemoryGame(); // Redraw with new canvas size
                } else { 
                    memoryDifficultyButtons.style.display = 'flex';
                    memoryGameCanvas.style.display = 'none';
                    memoryGameInfo.style.display = 'none'; 
                    memoryGameCanvas.width = 0;
                    memoryGameCanvas.height = 0;
                    memoryCtx.clearRect(0, 0, 0, 0);
                }
            } else if (currentActiveGameType === 'reaction' && reactionGameScreen.classList.contains('active') && currentReactionDifficulty) {
                 // ìˆœë°œë ¥ ê²Œì„ì€ ë‚œì´ë„ ë²„íŠ¼ ìˆ¨ê¹€ ìƒíƒœ ìœ ì§€
                 reactionDifficultyButtons.style.display = 'none'; 
                 reactionGamePlayArea.style.display = 'flex'; 
                 // í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ê²Œì„ ìƒíƒœë¥¼ ìœ ì§€í•˜ë©´ì„œ ìº”ë²„ìŠ¤ í¬ê¸°ë§Œ ì¬ì¡°ì •

                 // ë°˜ì‘í˜• ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì • ë¡œì§ (startReactionGameê³¼ ë™ì¼í•˜ê²Œ)
                 const appHeight = document.getElementById('app').clientHeight;
                 const appWidth = document.getElementById('app').clientWidth;
                 const screenPaddingTop = 25; 

                 const originalGameInfoDisplay = reactionGameInfo.style.display;
                 reactionGameInfo.style.display = 'flex'; 
                 const gameInfoHeight = reactionGameInfo.offsetHeight;
                 reactionGameInfo.style.display = originalGameInfoDisplay; 

                 const canvasMarginBottom = 25; 

                 const availableVerticalSpaceForCanvas = appHeight - screenPaddingTop - gameInfoHeight - canvasMarginBottom;
                 
                 const canvasRenderWidth = appWidth - (2 * CANVAS_HORIZONTAL_PADDING);
                 
                 const cardSpacing = 10;
                 const tempCols = currentReactionDifficulty.cols;
                 const tempRows = currentReactionDifficulty.rows;

                 const idealCardWidth = (canvasRenderWidth - ((tempCols - 1) * cardSpacing)) / tempCols;
                 const idealCardHeight = idealCardWidth; 

                 let idealCanvasHeight = (tempRows * idealCardHeight) + ((tempRows - 1) * cardSpacing);

                 let finalCanvasWidth = canvasRenderWidth;
                 let finalCanvasHeight;

                 if (idealCanvasHeight > availableVerticalSpaceForCanvas) {
                     finalCanvasHeight = availableVerticalSpaceForCanvas;
                     const newCardHeight = (finalCanvasHeight - ((tempRows - 1) * cardSpacing)) / tempRows;
                     const newCardWidth = newCardHeight; 
                     finalCanvasWidth = (tempCols * newCardWidth) + ((tempCols - 1) * cardSpacing);
                 } else {
                     finalCanvasHeight = idealCanvasHeight;
                 }

                 reactionGameCanvas.width = finalCanvasWidth;
                 reactionGameCanvas.height = finalCanvasHeight;
                 
                 // ê¸°ì¡´ ë£¨í”„ë¥¼ ì¤‘ì§€í•˜ê³  ìƒˆ ë£¨í”„ ì‹œì‘
                 stopReactionGameLoop();
                 stopReactionAnimationLoop(); // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ë„ ì¤‘ì§€
                 // ì¬ì¡°ì •ëœ ìº”ë²„ìŠ¤ì— ë‹¤ì‹œ ê·¸ë¦¬ê³ , ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ë‹¤ì‹œ ì‹œì‘
                 startReactionAnimationLoop(); 
                 startReactionGameLoop(); 
            }
        });

        // ì´ˆê¸° ë¡œë“œ ì‹œ í™ˆ í™”ë©´ìœ¼ë¡œ
        window.onload = () => {
            showScreen('home-screen');
        };
        // JavaScript ë
    </script>
</body>
</html>
